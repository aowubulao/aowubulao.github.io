<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>在Java中使用协程 - 协程实践</title>
    <link href="/posts/using-coroutines%20in-java/"/>
    <url>/posts/using-coroutines%20in-java/</url>
    
    <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>协程在2022年已经不是什么新鲜的东西，甚至可以说有一点烂大街了，但是最近在工作中真正地用上了协程，并且带来了很大的性能提升，这里做一个简单的分享。</p><p>其实在这段时间的工作中都在优化这个服务的性能（一个日常单机1000+QPS的应用），应该算并发比较高的服务了，虽然平均rt等指标看上去都很正常，但是P95 P99等都不那么好看，甚至有一点糟糕，一些服务的兜底率也偏高。</p><p>期间尝试过优化代码、调整JVM参数控制GC，虽然有一定的提升，但是P95 P99始终是一把悬着的利剑，有时候服务的最大响应时间也会彪上1s。</p><p>这个时候我们来分析一下这个服务：高并发、IO型，并没有太多的计算，那么这个服务的线程切换一定非常频繁，因为它不仅需要处理上游的请求，还要同时向下游发起调用，所以当时我想到了开启协程试一下，正巧公司JDK使用的都是支持协程的dragonwell，同时之前其他应用也有开启的前例，并没有出现任何问题。</p><h2 id="2、Java如何使用协程"><a href="#2、Java如何使用协程" class="headerlink" title="2、Java如何使用协程"></a>2、Java如何使用协程</h2><p>Java原生并不支持协程，但是阿里提供了支持协程的JDK：</p><blockquote><p>阿里巴巴有着最丰富的Java应用场景，覆盖电商，金融，物流等众多领域，世界上最大的Java用户之一。 作为OpenJDK的下游， Alibaba Dragonwell是阿里巴巴内部OpenJDK定制版AJDK的开源版本， AJDK为在线电商，金融，物流做了结合业务场景的优化，运行在超大规模的，100,000+ 服务器的阿里巴巴数据中心。Alibaba Dragonwell是OpenJDK的下游(friendly fork)，使用了和OpenJDK一样的licensing。阿里会更紧密地和OpenJDK等开源社区协作， 贡献更多的patches， 促进Java技术的持续发展。</p></blockquote><p>dragonwell只支持linux和windows系统，所以使用macos的各位暂时不能在本机上进行调试（实际上应该也不需要）</p><p>这里就不赘述如何安装JDK了，dgragonwell有很多其他功能，我们这里主要介绍Wsip这个功能：</p><blockquote><p>Wisp2 是在JVM层面实现的有栈对称式协程。相较于Kotlin、Kilim等字节码方案来说，Wisp在JDK阻塞接口上插入了调度支持，因此可以让现有Java应用无需改动地获得协程所带来的性能提升。</p></blockquote><p>简单来说就是Wsip可以在无侵入的情况下实现Java的协程。</p><h2 id="3、开启协程并调试"><a href="#3、开启协程并调试" class="headerlink" title="3、开启协程并调试"></a>3、开启协程并调试</h2><p>对于Java应用来说，并不是所有线程都适合开启协程的，像Netty、一些内核线程等都不太适合开启协程，我们可以通过设置白名单的方式将我们的一些业务线程转换为协程。</p><p>使用如下启动参数：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment">#开启协程</span><br>-XX:+UseWisp2 <br><span class="hljs-comment">#不让所有的线程都转换为协程</span><br>-Dcom.alibaba.wisp.enableThreadAsWisp=<span class="hljs-literal">true</span><br><span class="hljs-comment">#指定开启协程的线程池</span><br>-Dcom.alibaba.wisp.threadAsWisp.white=<span class="hljs-built_in">name</span>:DubboServerHandler*;<span class="hljs-built_in">name</span>:your-thred-pool-<span class="hljs-built_in">name</span>*<br></code></pre></td></tr></table></figure><p>这样，我们可以让你的业务线程池、Dubbo业务线程池开启协程，实践中可以根据需要调整参数。</p><p>到这里其实我们就成功开启了协程，那么问题来了，怎么知道协程是否成功开启了呢？</p><p>答案是使用jstack，jstack等工具已经支持了协程。</p><p>服务运行后jstack pid &gt; o.txt，我们用vi/vim搜索你自己的线程名，就可以得到如下结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">- Coroutine [0x7f227dae47e0] <span class="hljs-string">"thread-pool-name-1"</span> <span class="hljs-attribute">active</span>=2394347 <span class="hljs-attribute">steal</span>=378779 <span class="hljs-attribute">steal_fail</span>=968 <span class="hljs-attribute">preempt</span>=0 <span class="hljs-attribute">park</span>=0/-1<br>Wsip<span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure><ul><li>active表示协程被调度的次数</li><li>steal表示work stealing发生的次数</li><li>preempt 表示抢占的次数</li></ul><p>如果下面的堆栈出现了Wsip的字样，那说明协程已经成功开启啦</p><h2 id="4、性能"><a href="#4、性能" class="headerlink" title="4、性能"></a>4、性能</h2><p>过程固然重要，但是如果性能不好那也只是徒劳。</p><p>Wsip官方提供的性能测试中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java">             o      .   _______ _______<br>              \_ <span class="hljs-number">0</span>     /______<span class="hljs-comment">//______/|   @_o</span><br>                /\_,  /______<span class="hljs-comment">//______/     /\</span><br>               | \    |      ||      |     / |<br><br>                 <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ExecutorService THREAD_POOL = Executors.newCachedThreadPool();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    BlockingQueue&lt;Byte&gt; q1 = <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;(), q2 = <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;();<br>    THREAD_POOL.submit(() -&gt; pingpong(q2, q1)); <span class="hljs-comment">// thread A</span><br>    Future&lt;?&gt; f = THREAD_POOL.submit(() -&gt; pingpong(q1, q2)); <span class="hljs-comment">// thread B</span><br>    q1.put((<span class="hljs-keyword">byte</span>) <span class="hljs-number">1</span>);<br>    System.out.println(f.get() + <span class="hljs-string">" ms"</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">pingpong</span><span class="hljs-params">(BlockingQueue&lt;Byte&gt; in, BlockingQueue&lt;Byte&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1_000_000</span>; i++) out.put(in.take());<br>    <span class="hljs-keyword">return</span> System.currentTimeMillis() - start;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$java</span> PingPong</span><br><span class="hljs-number">13212</span> ms<br><br><span class="hljs-comment">// 开启Wisp2</span><br><span class="hljs-meta"><span class="hljs-meta-keyword">$java</span> -XX:+UnlockExperimentalVMOptions -XX:+UseWisp2 -XX:ActiveProcessorCount=1 PingPong</span><br><span class="hljs-number">882</span> ms<br></code></pre></td></tr></table></figure><p>可以看到对于线程切换频繁的应用，协程带来的提升是巨大的。</p><p>在实践中也印证了这个理论，在开启协程前一个上游应用的调用监控中：P95 P99大约都在250-500ms来回横跳（抖动），服务的尾请求非常的不稳定，开启协程后基本都稳定在200-250ms，几乎没有抖动，应用自己的监控，接口最大响应时间也几乎没有以前的抖动，可以说性能提升巨大。</p><h2 id="5、其他"><a href="#5、其他" class="headerlink" title="5、其他"></a>5、其他</h2><p>其实本篇文章基本没有什么技术含量，算是一个小小的日记，对于很多Java开发者来说，有的可能接触过其他语言，如Go的协程，但是大多数人实际上是没有在生产环境中实际使用过协程的。如果你也正在为一些性能问题所困扰，或许可以试试这款JDK，网络上很多人因为阿里的原因对这个JDK存在偏见，但是凡事都得真正使用一下，才能知道它到底几斤几两。</p><p>当然，协程也不是什么银弹，之前也有其他服务开启过协程，并没有带来什么收益，需要具体应用具体分析。</p><p>参考：</p><p><a href="https://github.com/alibaba/dragonwell8/wiki/Wisp%E6%96%87%E6%A1%A3" target="_blank" rel="noopener">dgragonwell-docs</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gen3 红蓝宝石有电模拟器野外乱数闪光教程</title>
    <link href="/posts/cache-false-share%20-%20%E5%89%AF%E6%9C%AC/"/>
    <url>/posts/cache-false-share%20-%20%E5%89%AF%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="1、开始"><a href="#1、开始" class="headerlink" title="1、开始"></a>1、开始</h2><h3 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h3><p>首先，本文大量参考了其他教程、攻略的内容，但是其他攻略或多或少都有描述不清楚的地方，然后在实际操作的过程中走了很多歪路，所以本文着重讲解日版红蓝宝石（模拟器有电）情况下的野生宝可梦乱数闪光。</p><p>因为本人是使用的GBA实机卡带，所以会从提取GBA存档到乱数到回写存档一步一步进行，保证不遗漏任何细节。</p><p>大量内容出自以下两位大佬的攻略：</p><ol><li>大碗宽面的帖子：[【怀旧向乱数攻略】红蓝宝石电池未耗尽模拟器乱数](<a href="https://tieba.baidu.com/p/7731770160" target="_blank" rel="noopener">【图片】【怀旧向乱数攻略】红蓝宝石电池未耗尽模拟器乱数【口袋妖怪吧】_百度贴吧 (baidu.com)</a>)</li><li>丘丘大佬的博客：<a href="https://willkyu.github.io/Pokemon/Strategies/In-Game/RNG/Pokemon-RNG-Abuse-Gen3-Part2/" target="_blank" rel="noopener">宝可梦有电的红蓝宝石实机乱数（不包含 ID 或 Egg） | 丘丘 Blog (willkyu.github.io)</a></li></ol><p>其中本文中用到的工具都可以从贴吧的帖子中的链接获取，为了防止链接被炸，<strong>可以从上述链接1的2楼-楼中楼中获取</strong>。</p><h3 id="1-2-准备工作"><a href="#1-2-准备工作" class="headerlink" title="1.2 准备工作"></a>1.2 准备工作</h3><p>你可能需要：</p><ol><li><strong>pkhex</strong> - 主要用于查看训练师的里ID: <a href="https://projectpokemon.org/home/files/file/1-pkhex/" target="_blank" rel="noopener">链接</a></li><li><strong>使用nds提取GBA卡带存档（如果你是单纯的模拟器玩家可以忽略）</strong>：<a href="https://tieba.baidu.com/p/6349601583" target="_blank" rel="noopener">全版本正版游戏卡带存档导出导入教程</a></li><li><strong>原版rom下载：</strong><a href="https://www.oldmanemu.net/掌机游戏/gba/gba官方游戏全集" target="_blank" rel="noopener">GBA游戏下载</a></li></ol><h3 id="1-3-有问题"><a href="#1-3-有问题" class="headerlink" title="1.3 有问题"></a>1.3 有问题</h3><p>如果你看完这篇文章，在操作过程中还有其他问题，或者上述资源失效，都可以通过邮箱联系到我：<a href="mailto:me@neow.cc">me@neow.cc</a></p><h2 id="2、关于乱数"><a href="#2、关于乱数" class="headerlink" title="2、关于乱数"></a>2、关于乱数</h2><p>本文就不讲解乱数的原理了，如果你想了解相关知识，网上还是有很多教程的。</p><p>为什么要使用乱数呢，其实从前言你大概已经知道了，想要利用乱数刷闪，或多或少还是会用到一些非正版的东西，取决于大家的心里洁癖程度。</p><p>如果你不排斥使用存档提取，但是排斥使用模拟器，那可以查看丘丘的博客使用实机进行乱数。</p><p>如果你像我一样能够接受存档提取、使用模拟器，那本文是很适合你的。</p><p>再往上一层，如果你只追求宝可梦的合法，那大可使用RNGreporter、3gensearch刷出闪光然后pkhex捏出对应的宝可梦就行。</p><p>其他的就不废话了，我们赶紧进入正题。</p><h2 id="3、开始操作"><a href="#3、开始操作" class="headerlink" title="3、开始操作"></a>3、开始操作</h2><h3 id="3-1-GBA卡带存档提取"><a href="#3-1-GBA卡带存档提取" class="headerlink" title="3.1 GBA卡带存档提取"></a>3.1 GBA卡带存档提取</h3><p>如果你是模拟器玩家请直接跳过本小节。</p><p><strong>提取GBA存档需要你有一台NDS或NDSL，以及一张r4烧录卡</strong></p><p>首先阅读1.2准备工作的第2条帖子，其中2楼有资源，5楼为提取教程。</p><p>因为本人也因为误操作在提取存档时被删过存档，所以个人建议使用以下方法操作：</p><p>1、在r4烧录卡的sd卡根目录新建文件夹：GBA_Backup</p><img src="https://img.neoniou.com/blog/20221124225201.png" srcset="/img/loading.gif" style="zoom:50%;" /><p>2、在电脑模拟器上随便开一个档保存，将存档放入改文件夹</p><p>3、将烧录卡和GBA卡带插入nds，打开GBA存档提取软件</p><img src="https://img.neoniou.com/blog/20221124225400.png" srcset="/img/loading.gif" style="zoom: 25%;" /><p>4、在此界面，使用方向键选择第2步中放入的存档</p><p>5、点击A同步，随后即完成提取。</p><h3 id="3-2-下载原版rom"><a href="#3-2-下载原版rom" class="headerlink" title="3.2 下载原版rom"></a>3.2 下载原版rom</h3><p>因为本文主要使用日版红/蓝宝石进行，如果你是实机玩家，请下载对应卡带的版本，如果你跳过了3.1小节，那么建议你下载日版蓝宝石的rom，因为本人使用的也是蓝宝石，当然，这两个版本差别几乎没有，可以挑选你喜欢的rom下载。</p><p>下载地址前面已经给出。</p><h3 id="3-3-下载原版rom"><a href="#3-3-下载原版rom" class="headerlink" title="3.3 下载原版rom"></a>3.3 下载原版rom</h3>]]></content>
    
    
    <categories>
      
      <category>宝可梦</category>
      
    </categories>
    
    
    <tags>
      
      <tag>宝可梦</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo线程池隔离以及动态线程池</title>
    <link href="/posts/dubbo-thread-pool-isolation-and-dynamic/"/>
    <url>/posts/dubbo-thread-pool-isolation-and-dynamic/</url>
    
    <content type="html"><![CDATA[<p>很久没发博客了，想着偶尔还是来写写东西~</p><blockquote><p>内容中有不少省略的代码，其中也有很多关键性的东西，不过内容和公司框架高度耦合，涉及的东西也比较多，所以也懒得修改后放出来了，直接做了跳过。</p></blockquote><h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><p>在目前我负责的系统中，有一个网关，有http请求，也有dubbo请求，这里主要讨论dubbo接口的请求。</p><p>当然，作为一个网关，必然承载了上万的QPS，在这几万的QPS请求中，有着各种各样的场景，不同场景的RT也不尽相同，少的只有约10-20ms，而高的则达到150-200ms，其中场景当然也分主要场景以及不那么重要的场景。</p><p>在这种QPS的请求下，所有的场景都使用的同一个dubbo线程池，就会带来以下两个问题：</p><p><strong>1、无法隔离场景请求</strong></p><p>有可能低重要度的场景下游出现问题，导致RT升高，从而影响线程池中的其他重要场景</p><p><strong>2、无法精细地看到场景线程池的运行情况</strong></p><p>这个就很好理解了，毕竟即使是线程池监控，那么也只能够看到一个总体的情况，具体某个场景的线程运行情况我们自然无法得知。</p><h2 id="2、解决方案以及扩展"><a href="#2、解决方案以及扩展" class="headerlink" title="2、解决方案以及扩展"></a>2、解决方案以及扩展</h2><h3 id="2-1-dubbo请求流程"><a href="#2-1-dubbo请求流程" class="headerlink" title="2.1 dubbo请求流程"></a>2.1 dubbo请求流程</h3><p>其实想一下还是很简单的，我们只要根据请求参数中的场景信息来选择对应的线程池不就行了嘛。</p><p>这里直接上dubbo请求流程：</p><img src="https://dubbo.apache.org/imgs/dev/dubbo-framework.jpg" srcset="/img/loading.gif" style="zoom: 80%;" /><p>我们可以先把目光放到整张图的右下角，ChannelHandler &lt;- Dispathcer -&gt; ThreadPool，这三个就是我们要关注的地方，当dubbo请求经过server后，会被ChannelHandler处理，ChannelHandler会选择对应的处理器（Dispatcher），而Dispathcer也会相应地选择相应的线程池。</p><p>上一个dubbo的配置就可以很明显地看出来，这个dispatcher是message，而其使用的是core为200的fixedPool。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">dubbo.protocol.threadpool</span>=<span class="hljs-string">fixed</span><br><span class="hljs-meta">dubbo.protocol.threads</span>=<span class="hljs-string">200</span><br><span class="hljs-meta">dubbo.protocol.dispatcher</span>=<span class="hljs-string">message</span><br></code></pre></td></tr></table></figure><p>那么这个message dispacther是干了什么呢？</p><p>因为就这个处理器就几行代码，所以我们直接看代码吧。</p><p>我们可以看到MessageDispacther实际只处理了接收的消息，然后把这个消息扔进了一个线程池里执行，这其实和我们的目的很接近了！因为我们想要的其实和这个message处理器很接近，区别就是我们想根据请求参数的不同，把他们扔进不同的线程池里处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageOnlyChannelHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WrappedChannelHandler</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageOnlyChannelHandler</span><span class="hljs-params">(ChannelHandler handler, URL url)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(handler, url);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">received</span><span class="hljs-params">(Channel channel, Object message)</span> <span class="hljs-keyword">throws</span> RemotingException </span>&#123;<br>        ExecutorService executor = getPreferredExecutorService(message);<br>        <span class="hljs-keyword">try</span> &#123;<br>            executor.execute(<span class="hljs-keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            <span class="hljs-keyword">if</span>(message <span class="hljs-keyword">instanceof</span> Request &amp;&amp; t <span class="hljs-keyword">instanceof</span> RejectedExecutionException)&#123;<br>                sendFeedback(channel, (Request) message, t);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ExecutionException(message, channel, getClass() + <span class="hljs-string">" error when process received event ."</span>, t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-第一步，线程池隔离"><a href="#2-2-第一步，线程池隔离" class="headerlink" title="2.2 第一步，线程池隔离"></a>2.2 第一步，线程池隔离</h3><p>既然这个message dispacther和我们的需求差别已经不远了，就直接写一个这个类的子类吧。</p><p>那么怎么获取这次dubbo的请求参数呢，别急，看received这个方法上的message参数，这个就是这次请求的请求参数，不过这个请求参数是encode的状态，我们需要把这个参数decode一下，转成我们需要的请求参数。因为在dpp网关中，两个推荐请求的入参的父类都是同一个，所以我们可以很轻松地进行类型的转换。</p><p>来看下代码吧，因为代码里有注释，这里就不多解释了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getRequestScene</span><span class="hljs-params">(Object message)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 只处理recieved的Request</span><br>            <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">instanceof</span> Request) &#123;<br>                <span class="hljs-comment">// decode Object</span><br>                decode(((Request) message).getData());<br>                RpcInvocation inv = (RpcInvocation) ((Request) message).getData();<br>                <span class="hljs-comment">// 获取具体的请求参数，我们只用获取带场景的那个参数就可以了</span><br>                <span class="hljs-keyword">for</span> (Object requestParam : inv.getArguments()) &#123;<br>                    <span class="hljs-keyword">if</span> (requestParam <span class="hljs-keyword">instanceof</span> YourRequest) &#123;<br>                        <span class="hljs-comment">// 获取场景</span><br>                        <span class="hljs-keyword">return</span> ((YourRequest) requestParam).getScene();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.warn(<span class="hljs-string">"Decode message error: "</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>有个这个基础，我们就能根据场景来进行线程池的隔离了，剩下的大部分代码其实都是从配置中心读取相应场景的线程池配置等等…</p><p>最后别忘了在dubbo中配置spi拓展，将你写的这个自定义dispacther注册到dubbo中。</p><h3 id="2-2-动态线程池管理"><a href="#2-2-动态线程池管理" class="headerlink" title="2.2 动态线程池管理"></a>2.2 动态线程池管理</h3><p>既然都做到了这一步，为什么不再整点活呢？如果你看过美团那篇动态线程池的文章，其实可以知道：动态管理线程池并不是什么难事，毕竟JDK的线程池已经给你提供了对应的接口修改coreSize以及poolSize等参数，其实只用监听配置中心的变化，根据参数实时更改就可以了~</p><h3 id="2-3-线程池监控"><a href="#2-3-线程池监控" class="headerlink" title="2.3 线程池监控"></a>2.3 线程池监控</h3><p>当然，监控也是必不可少的一环。既然根据场景隔离了线程池，那么我也当然想看各个线程池的运行情况对吧，这个实现起来也很简单。</p><p>其实dubbo本身提供了一个map存放线程池，然后根据handler以及端口等参数从中取(虽然实际上如果你使用默认参数来配置的话里面就一个线程池而已)。</p><p>综上，我们也没必要造轮子，直接把我们创建的自定义线程池扔进dubbo的线程池repo里去就行了，这样在监控线程池的时候，只用从一个地方读取参数，简单多了。</p><p>这里放一个获取dubbo线程池map的代码，因为本身是private的，所以需要反射来获取。</p><p>至于监控，就写个定时任务读取线程池，然后往promethus中扔就行啦~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取Dubbo的线程池map</span><br><span class="hljs-comment">     * &lt;br/&gt;</span><br><span class="hljs-comment">     * 获取到后将dpp创建的线程池放入该map中，用作监控</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Dubbo的线程池map</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"all"</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ConcurrentMap&lt;String, ConcurrentMap&lt;Integer, ExecutorService&gt;&gt; getDubboThreadPoolMap() &#123;<br>        <span class="hljs-keyword">if</span> (executorServiceMap != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> executorServiceMap;<br>        &#125;<br>        ExecutorRepository executorRepository =<br>                ExtensionLoader.getExtensionLoader(ExecutorRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getDefaultExtension</span>()</span>;<br>        <span class="hljs-keyword">if</span> (!(executorRepository <span class="hljs-keyword">instanceof</span> DefaultExecutorRepository)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        Field data;<br>        <span class="hljs-keyword">try</span> &#123;<br>            data = DefaultExecutorRepository.class.getDeclaredField("data");<br>            data.setAccessible(<span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">synchronized</span> (DppSceneThreadPoolRepo<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;<br>                <span class="hljs-keyword">if</span> (executorServiceMap != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> executorServiceMap;<br>                &#125;<br>                executorServiceMap =<br>                        (ConcurrentMap&lt;String, ConcurrentMap&lt;Integer, ExecutorService&gt;&gt;) data.get(executorRepository);<br>                <span class="hljs-keyword">return</span> executorServiceMap;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br>            log.warn(<span class="hljs-string">"无法获取dubbo线程池map[&#123;&#125;],线程池监控会受到影响"</span>, e.getMessage());<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="3、上线以及后记"><a href="#3、上线以及后记" class="headerlink" title="3、上线以及后记"></a>3、上线以及后记</h2><p>到这里这篇文章基本就结束了，我们最后实现了一个：动态dubbo线程池，同时还具备场景隔离功能，然后带线程池详细数据监控，可以说基本完美了。</p><p>其实我们还可以继续举一反三，将服务中的各个线程都做到精细化、动态化配置管理以及监控，从而更好地掌握服务的运行情况。</p><p>在写下这篇博客的时候，这个功能已经在生产环境运行了大半年了，其中经历了春节、618等大促，以及大大小小各种压测，提升了服务稳定性，看着监控调线程池也是真爽~</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈阻塞以及协程</title>
    <link href="/posts/talking-about-blocking-and-coroutine/"/>
    <url>/posts/talking-about-blocking-and-coroutine/</url>
    
    <content type="html"><![CDATA[<h2 id="序、提出的问题"><a href="#序、提出的问题" class="headerlink" title="序、提出的问题"></a>序、提出的问题</h2><p>在正式开始之前，我想先提出几个问题，然后一起带着问题以及思考去阅读这篇文章</p><p><strong>1、什么是协程</strong></p><p><strong>2、协程的作用是什么</strong></p><h2 id="一、阻塞与非阻塞"><a href="#一、阻塞与非阻塞" class="headerlink" title="一、阻塞与非阻塞"></a>一、阻塞与非阻塞</h2><p>首先我们来回顾一些基础的概念，对于<strong>操作系统</strong>来说，什么是阻塞和非阻塞呢？</p><p>阻塞和非阻塞的区别在于：是否立即返回数据，在非阻塞的模型中，应用发起请求（比如IO请求后），系统会立即返回，程序可以再次发起请求，直到系统处理完毕，返回数据。</p><p><img src="https://img.neoniou.com/blog/20211220200208.png" srcset="/img/loading.gif" alt=""></p><p>这里写了一个小的demo，实现非阻塞IO读取本地文件，可以从代码中看出，在读取文件并且未读取完成的时候，系统会返回<strong>EAGAIN</strong>，线程不断地轮询，直到系统读取完成并返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MSG_TIMEOUT <span class="hljs-meta-string">"timeout\n"</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">long</span> n;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, fd;<br>    <span class="hljs-keyword">int</span> timeout = <span class="hljs-number">100</span>;<br>    fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">"/Users/admin/neo/tmp/test.txt"</span>, O_RDONLY | O_NONBLOCK);<br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (; i &lt; timeout; ++i) &#123;<br>        n = <span class="hljs-built_in">read</span>(fd, buf, <span class="hljs-number">1024</span>);<br>        <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (errno != EAGAIN) &#123;<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i == timeout) &#123;<br>        <span class="hljs-built_in">write</span>(STDOUT_FILENO, MSG_TIMEOUT, <span class="hljs-built_in">strlen</span>(MSG_TIMEOUT));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">write</span>(STDOUT_FILENO, buf, n);<br>    &#125;<br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、多路复用"><a href="#二、多路复用" class="headerlink" title="二、多路复用"></a>二、多路复用</h2><p>即使是非阻塞模型，应用的每一个请求，依然需要创建一个线程去处理，这显然也不是一种很优雅的解决方法。如何用少的线程管理多的请求呢，答案是多路复用。</p><p>在多路复用的场景下，系统将请求的可写可读操作分离了出来，使用单独的线程进行管理。举个例子，系统可以创建3个线程处理6个请求，当6个请求进入的时候，会经过多路复用器，多路复用器会阻塞请求线程，同时轮询是否有空闲线程，如果有空闲线程的话就分配并进行读写操作。</p><p>虽然线程在读写时依然是阻塞的，但是配合非阻塞的IO操作，依然可以实现高并发下的网络连接，这就是reactor模型。</p><p><img src="https://img.neoniou.com/blog/20211220200259.png" srcset="/img/loading.gif" alt=""></p><h2 id="三、异步"><a href="#三、异步" class="headerlink" title="三、异步"></a>三、异步</h2><p>不难发现即使是多路复用，依然有<strong>阻塞</strong>的产生，异步的概念随之而来。与异步相关的另一个名词：<strong>回调</strong>，可以很好地解释异步这个概念。异步在发起请求后不会阻塞，而是会继续处理其他请求，当系统IO处理完成后，会<strong>通知程序处理返回</strong>。程序不用阻塞、反复地轮询是否ready，可以直接切换到其他任务，等待回调即可。</p><p>不仅是异步，在上述的多路复用模型中，都有<strong>等待数据返回</strong>这一个操作，当多个事件都需要回调时，代码会变得非常复杂。在Java中的Netty框架封装了基于nio(同步非阻塞)的多路复用，让IO的调用变得快速且简单，同时它也有另外一种解决方法：协程。</p><h2 id="四、什么是协程"><a href="#四、什么是协程" class="headerlink" title="四、什么是协程"></a>四、什么是协程</h2><blockquote><p>A coroutine is a <strong>function</strong> that can <strong>suspend</strong> its execution (yield) until the given given <strong>YieldInstruction</strong> finishes.</p></blockquote><p>首先想要说明，在我个人的理解里，协程更多的是一种技术的概念，而非一种技术的实现，协程没有一个统一的定义，通俗地讲：协程就是一个基于用户态的轻量的线程，它可以实现线程的一些功能，但又对kernel不可见，调度都由程序控制。</p><p>如果熟悉操作系统的话，我们可以知道，系统对线程的调度是<strong>抢占式</strong>的，即线程的资源控制权利在系统，不在用户。协程便可以实现<strong>协作式</strong>的调度，即用户有权利控制自己占有多久协程。</p><p><strong>ps</strong>:协作式的调度会出现一个协程占用过多的时间，不交出资源的情况，golang在1.14引入了抢占式协程调度，而kotlin对协程的实现依然是协作式的，由此来看，<strong>协程更多的只是一个概念</strong>，每个人，每个语言，都可以用不同的方式去实现，js等语言的async await的实现我认为也可以算协程，即使它是无栈协程。有栈和无栈的协程相关知识不在这里展开，感兴趣的话可以查看文章：<a href="https://mthli.xyz/stackful-stackless/" target="_blank" rel="noopener">有栈协程与无栈协程</a>。</p><p>因此协程的开启以及切换的开销和线程对比起来，都小了很多。用线程的话可能我们最多只能开启几千个线程，但是协程我们可以做到几万甚至更多。</p><p><img src="https://img.neoniou.com/blog/20211220200357.png" srcset="/img/loading.gif" alt=""></p><p>提到协程，我们一瞬间基本上都能想到以下几个优点</p><ol><li><strong>节省内存</strong></li><li><strong>节省线程创建时syscall的开销</strong></li><li><strong>协程的切换开销很小</strong></li><li><strong>可以配合非阻塞IO，提高系统性能</strong></li></ol><h2 id="五、协程的作用是什么"><a href="#五、协程的作用是什么" class="headerlink" title="五、协程的作用是什么"></a>五、协程的作用是什么</h2><p>上文讨论了很多IO以及协程相关的问题，现在我们对看到协程都会形容它：轻量级的线程。对于我们程序员来说，这个轻量级的线程最大的作用是什么：<strong>提高程序速度</strong>？毕竟它比线程轻，能开几十上百万的协程。但协程最大的作用是：对异步以及回调的封装，让程序员可以用写同步代码的方法写异步IO。我们可以看一段golang的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">//省略</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   resp, _ := http.Get(<span class="hljs-string">"https://xxxxxx"</span>)<br>   body, _ := ioutil.ReadAll(resp.Body)<br>   fmt.Println(<span class="hljs-keyword">string</span>(body))<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码发起了一个网络IO请求，得到结果并输出，这是一个我们再熟悉不过的同步代码书写，但这其实是一个<strong>异步/回调</strong>的执行，在发起http请求后，go创建了一个新的<strong>协程</strong>去处理网络请求，并让出当前<strong>线程</strong>的资源去进行其他任务，当请求完成后再通过线程调度协程恢复，继续进行后续的处理。</p><p>让我们回到文章的开头，思考阻塞与非阻塞。当时提到：对<strong>操作系统</strong>来说，讲到这应该都清楚一件事，那就是线程是内核可以感知的，而协程是内核无法感知的，所以协程的”阻塞”，对于操作系统以及线程而言，都是”非阻塞”的状态，对于golang来说，当一个协程进行IO操作的时候，golang会在用户态阻塞这个协程，内核态是无感的，golang将这个协程yield出去，将资源分配给其他的go协程。这里的重点也是：协程的切换代价比线程的切换低了很多。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>下级系统网关的搭建</title>
    <link href="/posts/gateway-system/"/>
    <url>/posts/gateway-system/</url>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><h3 id="1-1-网关是什么"><a href="#1-1-网关是什么" class="headerlink" title="1.1 网关是什么"></a>1.1 网关是什么</h3><p>通俗地讲，网关就是一个入口，在当前微服务盛行的情况下，随着各种服务的拆分，API的数量也成倍地增长，所以我们需要一个系统来对这些API进行管理，完成协议转换、鉴权、限流、监控等功能。</p><h3 id="1-2-我需要什么"><a href="#1-2-我需要什么" class="headerlink" title="1.2 我需要什么"></a>1.2 我需要什么</h3><p>对于一个公司来说，大的服务网关通常已经搭建完毕，来负责公司各个服务的路由、鉴权，但是对于下级的服务来说，通常内部也需要一个”网关”的东西，接收来自外网的流量请求，然后进行协议转换、参数校验等自定义的行为，再发起内部HTTP/RPC请求，如图。</p><p>目前我们的框架承担着公司80%的推荐流量，每天上亿次的请求，现有的网关在可预见的未来，可能会成为数据链路上的短板，搭建一个新的网关系统也提上的日程。</p><p><img src="https://img.neoniou.com/blog/20210913201757.png" srcset="/img/loading.gif" alt=""></p><h2 id="二、网关的架构"><a href="#二、网关的架构" class="headerlink" title="二、网关的架构"></a>二、网关的架构</h2><p>首先可以看一下改进后的网关的架构</p><p><img src="https://img.neoniou.com/blog/20210913201903.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-1-pre-post层"><a href="#2-1-pre-post层" class="headerlink" title="2.1 pre+post层"></a>2.1 pre+post层</h3><p>该层负责着流量的进入以及参数的返回，在流量进入后，会进行协议的转换，来适配下游服务。</p><p>熔断、限流、降级等都是网关的基础功能，不做赘述。</p><p>对于推荐系统来说，存在着非常多的场景：首页推荐、社区推荐、交易单商品推荐…，不同的推荐场景通常由不同的算法、工程同学完成，内部也存在着不同的逻辑。在请求进入系统后，网关会根据不同的场景选择相应的场景自定义组件，来对请求参数做个性化的处理。</p><p>同时，对于一个推荐系统的网关来说，兜底也是一个重要的功能。目前的网关可以根据场景配置进行前置兜底：对请求转发、直接兜底返回，以及请求流程的后置兜底：返回参数为空，兜底精华池或进行二次请求兜底。</p><p>兜底虽然是一个重要的功能，但是对于算法同学来说，这里面的逻辑是不可见的，所以目前网关中的兜底避免了比较复杂的机制（手动配置兜底返回等功能），只做了一些简单的工作。</p><h3 id="2-2-routing层"><a href="#2-2-routing层" class="headerlink" title="2.2 routing层"></a>2.2 routing层</h3><p>在目前的推荐服务中，已经全部迁移到了dubbo，弃用了以前以feign为基础的rpc，所以在routing的阶段无需考虑一些协议的转换。</p><p>对于一个路由，主要的工作还是请求的转发、灰度、压测等功能。</p><p>为了方便链路的追踪、减少机器的压力，目前我们不同场景都对应着不同的集群，比如：场景A的流量会到集群A下的10台机器，场景B的流量会到集群B下的10台机器以及集群D下的8台机器。通过路由的判断，来分配这些请求的转发。</p><p>当然，仅有这样的分配是不够的，在大多数情况下，我们都有灰度、压测的需求，对于网关来说，还需要隔离这些请求，来防止影响线上健康的请求流量。除了上述的场景到机器的映射，这些不同的流量也会有不同的特征标签，routing层会根据这些标签，来判断是否为灰度、压测请求，来进行集群、机器的分配。同时，搭配自由的配置中心，完成线上的实时配置。</p><h4 id="2-2-1-服务隔离"><a href="#2-2-1-服务隔离" class="headerlink" title="2.2.1 服务隔离"></a>2.2.1 服务隔离</h4><p><img src="https://img.neoniou.com/blog/20210913201950.png" srcset="/img/loading.gif" alt=""></p><h4 id="2-2-2-可灰度，可压测"><a href="#2-2-2-可灰度，可压测" class="headerlink" title="2.2.2 可灰度，可压测"></a>2.2.2 可灰度，可压测</h4><p><img src="https://img.neoniou.com/blog/20210913202027.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-3-日志系统"><a href="#2-3-日志系统" class="headerlink" title="2.3 日志系统"></a>2.3 日志系统</h3><p>目前的系统是基于opentracing的全链路追踪，同时同步日志到阿里的SLS。除此之外，方便线上debug，在内网环境白名单的请求也会直接收集日志，并将推荐全链路日志返回，避免了拿到traceId再到SLS上去查询的麻烦操作。</p><h3 id="2-4-监控报警"><a href="#2-4-监控报警" class="headerlink" title="2.4 监控报警"></a>2.4 监控报警</h3><p>得益于公司完善的基架服务，监控以及报警都不需要下级的服务操心，直接接入基架组完成的监控以及报警系统并配置即可。本人也对监控报警了解不多，在此不做叙述。</p><h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h2><p>为了适配未来推荐系统的演进升级，本版网关是目前推荐架构下的第一次整合重构，因为开发人员并不多（设计和编写基本上都是本人完成TAT），所以还存在很多提升的空间，比如高可用，虽然目前整体服务的QPS已经达到了一个较高的值，但是保守的机器分配带来了低的单机QPS，单机的压力并不大，目前也不会遇到机器瓶颈。可能在QPS持续增加的未来，以及成本考虑，会开始考虑高可用的问题。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cache Line和内存伪共享</title>
    <link href="/posts/cache-false-share/"/>
    <url>/posts/cache-false-share/</url>
    
    <content type="html"><![CDATA[<h2 id="1、抛砖引玉"><a href="#1、抛砖引玉" class="headerlink" title="1、抛砖引玉"></a>1、抛砖引玉</h2><p>首先看一个概念，摘自：<a href="https://lmax-exchange.github.io/disruptor/disruptor.html#_cache_lines" target="_blank" rel="noopener">LMAX Disruptor: High performance alternative to bounded queues for exchanging data between concurrent threads</a>2.4</p><blockquote><p>The way in which caching is used in modern processors is of immense importance to successful high performance operation. Such processors are enormously efficient at churning through data and instructions held in cache and yet, comparatively, are massively inefficient when a cache miss occurs.</p><p>Our hardware does not move memory around in bytes or words. For efficiency, caches are organised into cache-lines that are typically 32-256 bytes in size, the most common cache-line being 64 bytes. This is the level of granularity at which cache coherency protocols operate. This means that if two variables are in the same cache line, and they are written to by different threads, then they present the same problems of write contention as if they were a single variable. This is a concept know as “false sharing”. For high performance then, it is important to ensure that independent, but concurrently written, variables do not share the same cache-line if contention is to be minimised.</p><p>When accessing memory in a predictable manner CPUs are able to hide the latency cost of accessing main memory by predicting which memory is likely to be accessed next and pre-fetching it into the cache in the background. This only works if the processors can detect a pattern of access such as walking memory with a predictable “stride”. When iterating over the contents of an array the stride is predictable and so memory will be pre-fetched in cache lines, maximizing the efficiency of the access. Strides typically have to be less than 2048 bytes in either direction to be noticed by the processor. However, data structures like linked lists and trees tend to have nodes that are more widely distributed in memory with no predictable stride of access. The lack of a consistent pattern in memory constrains the ability of the system to pre-fetch cache-lines, resulting in main memory accesses which can be more than 2 orders of magnitude less efficient.</p></blockquote><p>把重点内容翻译一下便是：</p><p>我们的硬件不会以字节为单位移动内存。为了提高效率，缓存被组装成大小为 32-256 字节的缓存行，最常见的缓存行是 64 字节。</p><p>如果不了解的话，可以先放在这，我们可以看一个简单的案例</p><h2 id="2、小案例"><a href="#2、小案例" class="headerlink" title="2、小案例"></a>2、小案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"all"</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheLineTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> LOOP_TIME = <span class="hljs-number">500000000L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ObjectA OBJECT_A = <span class="hljs-keyword">new</span> ObjectA();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ObjectB OBJECT_B = <span class="hljs-keyword">new</span> ObjectB();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//Case1</span><br>        <span class="hljs-keyword">double</span> case1Time = twoTaskRunner(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>; i &lt; LOOP_TIME; i++) &#123;<br>                OBJECT_A.num1++;<br>            &#125;<br>        &#125;, () -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>; i &lt; LOOP_TIME; i++) &#123;<br>                OBJECT_A.num2++;<br>            &#125;<br>        &#125;);<br>        System.out.println(<span class="hljs-string">"Case1 spend time: "</span> + case1Time);<br>        <span class="hljs-comment">//Case2</span><br>        <span class="hljs-keyword">double</span> case2Time = twoTaskRunner(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>; i &lt; LOOP_TIME; i++) &#123;<br>                OBJECT_B.num1++;<br>            &#125;<br>        &#125;, () -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>; i &lt; LOOP_TIME; i++) &#123;<br>                OBJECT_B.num2++;<br>            &#125;<br>        &#125;);<br>        System.out.println(<span class="hljs-string">"Case2 spend time: "</span> + case2Time);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">twoTaskRunner</span><span class="hljs-params">(Runnable task1, Runnable task2)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        Thread thread1 = <span class="hljs-keyword">new</span> Thread(task1);<br>        Thread thread2 = <span class="hljs-keyword">new</span> Thread(task2);<br><br>        thread1.start();<br>        thread2.start();<br><br>        thread1.join();<br>        thread2.join();<br>        <span class="hljs-keyword">return</span> (System.nanoTime() - start) / <span class="hljs-number">1E9</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Data</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectA</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> num1;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> num2;<br>    &#125;<br><br>    <span class="hljs-meta">@Data</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectB</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> num1;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * unused</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> p1, p2, p3, p4, p5, p6;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> num2;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * unused</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> p7, p8, p9, p10, p11, p12;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个非常简单易懂的小程序，两个Case都开了两个线程，去递增一个类中不同的两个int变量，唯一的区别是，ObjectB中，有了好几个没有使用的变量，我们可以来看看程序的执行时间</p><table><thead><tr><th>循环次数</th><th>Case1耗时(单位：秒)</th><th>Case2耗时(单位：秒)</th></tr></thead><tbody><tr><td>1M</td><td>0.0273049</td><td>0.0101989</td></tr><tr><td>10M</td><td>0.2711571</td><td>0.0717998</td></tr><tr><td>100M</td><td>2.842166399</td><td>0.6833727</td></tr><tr><td>1000M</td><td>29.0789099</td><td>6.7986955</td></tr></tbody></table><p>很明显，在加了一些无关紧要的变量后，程序的整体性能提升了几倍，这就要引出<strong>伪共享</strong>这概念了</p><h2 id="3、CPU缓存"><a href="#3、CPU缓存" class="headerlink" title="3、CPU缓存"></a>3、CPU缓存</h2><p>伪共享的产生和CPU的缓存机制存在着非常紧密的关系，我们在这可以简单地了解一下CPU的缓存机制</p><p>CPU缓存是介于CPU和内存间的临时存储器，容量很小但是很快，因为CPU的处理速度远大于内存的速度，所以需要设置CPU缓存来加快CPU的处理。</p><p>CPU缓存分为三个级别：L1、L2、L3，越靠近CPU缓存的容量越小，但速度也越快，所以L1缓存最小，但速度最快，L2容量大一些且速度慢于L1。L3容量最大，读写速度最慢，但不同于L1和L2只能被单独一个CPU核独占，L3则是多核共享。</p><p>当CPU执行运算的时候，它先去L1查询所需的数据，然后去L2和L3，如果缓存中没有数据，则所需的数据就去内存中拿。流程越长，则耗费的时间就会越长，为了提高读写性能，则尽可能将数据保存在L1缓存中。</p><p>进入缓存的数据以缓存行(Cache Line)为单位存储的，缓存容量通常为64字节，并且它有效地引用主存地址中的一块地址，以一个long类型的数据为例，它的大小为8字节，即一个缓存行最多可以存储8个，而系统在将数据从内存读入缓存时，并不是只将所需数据读入到缓存中，而是将在同一缓存行的所有数据都读入到缓存中。</p><p>如下图所示，如果CPU1需要读取数据X，则系统读取到缓存中的数据除了X，还会一并将它相邻的数据Y和数据Z读入到缓存中，即使它们可能并不会用到。如果CPU1需要使用数据Y，则只需要从L1中读取数据即可，不需要再从内存中读取数据了，因此可以大大提高数据处理的性能。</p><p><img src="https://img.neoniou.com/blog/20210820210353.png" srcset="/img/loading.gif" alt=""></p><p>以上是CPU缓存的工作原理，在数据的读取阶段，并不会发生任何的问题，但是如果CPU需要向内存中数据时，由于多核多线程的缘故，需要考虑如何解决数据一致性的问题。</p><p>如下图所示，当CPU1读数据X的同时CPU2写数据X，如果没有一定的机制进行并发处理，则会发生数据一致性问题，导致脏数据的出现。</p><p>当前主流保持数据一致性的方式是使用MESI协议，它的具体原理不在本篇详述，感兴趣的读者可以查阅相关资料，它的主要功能通俗地讲就是，如果一个CPU修改了某个缓存行，那么缓存系统的其他的CPU认为该缓存行是脏数据而丢弃，并重新从内存中读取最新的缓存行。</p><p>用下图的模型来解释，即当CPU修改数据X并写入到内存中后，则CPU1原先引用的缓存行将失效，需要重新从内存中读取最新的X数据。</p><p><img src="https://img.neoniou.com/blog/20210820210836.png" srcset="/img/loading.gif" alt=""></p><h2 id="4、伪共享的产生"><a href="#4、伪共享的产生" class="headerlink" title="4、伪共享的产生"></a>4、伪共享的产生</h2><p>以上就是CPU缓存系统的工作机制，而这个机制中就蕴藏着伪共享产生的温床。</p><p>当前很多文献对伪共享的非标准定义为：缓存系统中是以缓存行为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，即称为伪共享(false sharing)。</p><p>如下图所示，CPU1需要修改的数据X和CPU2需要修改的数据Z在同一个缓存行中，若CPU1先行修改成功，则根据MESI协议，CPU2中L1和L2的缓存行数据将一起失效，缓存系统需要从内存中读取到一批最新的包含有数据Z的缓存行进行修改，这在无形中就会影响到系统的整体性能。</p><p><img src="https://img.neoniou.com/blog/20210820210721.png" srcset="/img/loading.gif" alt=""></p><h2 id="4、伪共享的避免"><a href="#4、伪共享的避免" class="headerlink" title="4、伪共享的避免"></a>4、伪共享的避免</h2><p>既然已经知道了伪共享产生的机制，那如何避免伪共享呢？</p><p>一种方式是在有必要的情况下，可以用单核CPU代替多核CPU来处理任务，根据上述的模型，单核模型则不需要考虑多核之间的数据一致性问题，也不会存在一个缓存行被多核读取的问题，因此也不会存在伪共享的问题。</p><p>另一种方式是采用缓存行主动填充，这也是多核CPU环境下的主流处理方式，它的原理就是在一条有效数据之后主动添加若干条无意义的数据，从而保证该条有效数据可以独占整个缓存行。如下图所示：</p><p><img src="https://img.neoniou.com/blog/20210820211353.png" srcset="/img/loading.gif" alt=""></p><p>通过额外添加的数据，可以保证数据X和数据Z分隔在不同的缓存行中，即使出现缓存失效的状况，也可以做到相互之间互不影响，从而有效提高了系统的处理性能。回到一开始展示的代码，类ObjectB中那些无意义的long型数据其实就是利用上述的原理，作为缓存行的填充来挺高系统的处理效率。</p><h3 id="4-2、java中的做法"><a href="#4-2、java中的做法" class="headerlink" title="4.2、java中的做法"></a>4.2、java中的做法</h3><p>在JDK1.8中，为了解决伪共享的问题，引入了一个注解：@Contended，加上注解，并设置JVM参数：-XX:-RestrictContended，即可避免伪共享：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * with jvm : -XX:-RestrictContended</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Contended</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectA</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> num1;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> num2;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Case1 spend time:</span> <span class="hljs-number">0.6862326</span><br><span class="hljs-attr">Case2 spend time:</span> <span class="hljs-number">0.6865199</span><br></code></pre></td></tr></table></figure><h2 id="5、防止伪共享的一点弊端"><a href="#5、防止伪共享的一点弊端" class="headerlink" title="5、防止伪共享的一点弊端"></a>5、防止伪共享的一点弊端</h2><p>虽然避免伪共享对提高计算机处理性能有非常大的性能提升，但是该种技术当前并未成为主流，并且有许多人都是不了解或者未听说过该种技术。</p><p>原因就是因为它的弊端，使用避免伪共享技术主要会产生以下的弊端：</p><p>1、伪共享产生的条件苛刻且隐形。需要在多线程的环境，并且是对全局变量操作的过程中才会出现，并且伪共享的出现和代码的业务逻辑之间没有任何直接的关联，只能进入硬件层才能发现冲突产生的原因，但大部分开发者并不具备硬件开发或者调试的能力。</p><p>2、降低系统的性能。如果滥用缓存行填充技术，浪费CPU宝贵的cache资源，增加缓存系统读取内存的频率，从而降低了系统的性能。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot2.x整合dubbo2.7.8 + nacos1.4.0</title>
    <link href="/posts/spring-boot-nacos-dubbo/"/>
    <url>/posts/spring-boot-nacos-dubbo/</url>
    
    <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>今天在spring boot2.x下整合了一下dubbo2.7.8和nacos1.4.0，因为都是最新版，所以nacos和dubbo都有一些东西和网上的教程相比有所变化。</p><p>在写最新版的整合时，也会讲一下各个版本相对应的旧版的变化。</p><p>参考官方文档：</p><p><a href="http://dubbo.apache.org/zh/" target="_blank" rel="noopener">dubbo</a></p><p><a href="https://nacos.io/zh-cn/index.html" target="_blank" rel="noopener">nacos</a></p><h2 id="2、安装-nacos注册中心"><a href="#2、安装-nacos注册中心" class="headerlink" title="2、安装 nacos注册中心"></a>2、安装 nacos注册中心</h2><h3 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1 下载"></a>2.1 下载</h3><p>下载：<a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">github release</a></p><p>我使用的版本是1.4.0，两个压缩包只是对应了不用的操作系统的压缩，内容是一样的，所以任意选一个下载即可</p><p>部分文件结构：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">nacos</span><br>├── <span class="hljs-selector-tag">bin</span><br>│   ├── <span class="hljs-selector-tag">shutdown</span><span class="hljs-selector-class">.sh</span><br>│   ├── <span class="hljs-selector-tag">startup</span><span class="hljs-selector-class">.sh</span><br>│   ├── <span class="hljs-selector-tag">startup</span><span class="hljs-selector-class">.cmd</span><br>│   ├── <span class="hljs-selector-tag">shutdown</span><span class="hljs-selector-class">.cmd</span><br>├── <span class="hljs-selector-tag">conf</span><br>│   ├── <span class="hljs-selector-tag">application</span><span class="hljs-selector-class">.properties</span><br>│   ├── <span class="hljs-selector-tag">application</span><span class="hljs-selector-class">.properties</span><span class="hljs-selector-class">.example</span><br>│   ├── <span class="hljs-selector-tag">cluster</span><span class="hljs-selector-class">.conf</span><span class="hljs-selector-class">.example</span><br>│   ├── <span class="hljs-selector-tag">nacos-logback</span><span class="hljs-selector-class">.xml</span><br>│   ├── <span class="hljs-selector-tag">nacos-mysql</span><span class="hljs-selector-class">.sql</span><br>│   └── <span class="hljs-selector-tag">schema</span><span class="hljs-selector-class">.sql</span><br></code></pre></td></tr></table></figure><h3 id="2-2-修改启动文件"><a href="#2-2-修改启动文件" class="headerlink" title="2.2 修改启动文件"></a>2.2 修改启动文件</h3><p>因为新版nacos加入了cluster集群模式，而我们我目前只需要standalone单机模式，所以需要修改启动文件，不然每次都添加一个指令很麻烦</p><p>linux下修改startup.sh，windows下修改startup.cmd</p><p>windows：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">set</span> <span class="hljs-built_in">MODE</span>="standalone"<br></code></pre></td></tr></table></figure><p>linux：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export MODE="standalone"<br></code></pre></td></tr></table></figure><h3 id="2-3-配置数据库"><a href="#2-3-配置数据库" class="headerlink" title="2.3 配置数据库"></a>2.3 配置数据库</h3><p>nacos支持内置数据库，不过为了更方便管理，还是建立一个外部数据库比较好</p><p>在数据库中创建一个nacos相关的数据库，然后将 <strong>/conf/nacos-mysql.sql</strong> 文件执行即可</p><h3 id="2-4-修改配置文件"><a href="#2-4-修改配置文件" class="headerlink" title="2.4 修改配置文件"></a>2.4 修改配置文件</h3><p>配置文件：<strong>/conf/application.properties</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#修改为你的数据的信息</span><br><span class="hljs-meta">spring.datasource.platform</span>=<span class="hljs-string">mysql</span><br><br><span class="hljs-meta">db.num</span>=<span class="hljs-string">1</span><br><br><span class="hljs-meta">db.url.0</span>=<span class="hljs-string">jdbc:mysql://database-url:12345/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="hljs-meta">db.user</span>=<span class="hljs-string">nacos</span><br><span class="hljs-meta">db.password</span>=<span class="hljs-string">nacos</span><br></code></pre></td></tr></table></figure><h3 id="2-5-启动nacos"><a href="#2-5-启动nacos" class="headerlink" title="2.5 启动nacos"></a>2.5 启动nacos</h3><p>windows下双击startup.cmd即可</p><p>linux下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sh startup.sh<br><span class="hljs-meta">#</span><span class="bash">ubuntu</span><br>bash startup.sh<br></code></pre></td></tr></table></figure><p>根据提示的网址访问即可，默认的用户名和密码都是nacos</p><p><img src="https://img.neoniou.com/blog/2194sda.png" srcset="/img/loading.gif" alt=""></p><h2 id="3、项目整合"><a href="#3、项目整合" class="headerlink" title="3、项目整合"></a>3、项目整合</h2><p>我的整合demo: <a href="https://github.com/aowubulao/dubbo-demo" target="_blank" rel="noopener">https://github.com/aowubulao/dubbo-demo</a></p><p>项目目录</p><p><img src="https://img.neoniou.com/blog/20201218162624.png" srcset="/img/loading.gif" alt=""></p><p><strong>common-api</strong>：接口提供包，普通mavne项目，用于提供接口类</p><p><strong>service-consumer</strong>：dubbo消费者</p><p><strong>service-provider</strong>：dubbo提供者</p><h3 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h3><p>父类用于提供依赖管理</p><p>pom文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">netty.version</span>&gt;</span>4.1.56.Final<span class="hljs-tag">&lt;/<span class="hljs-name">netty.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">spring-boot.version</span>&gt;</span>2.3.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring-boot.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dubbo.version</span>&gt;</span>2.7.8<span class="hljs-tag">&lt;/<span class="hljs-name">dubbo.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">nacos-client.version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">nacos-client.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-dependencies-bom<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;dubbo.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;dubbo.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-registry-nacos<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;dubbo.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.nacos<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>nacos-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;nacos-client.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;dubbo.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="common-api模块"><a href="#common-api模块" class="headerlink" title="common-api模块"></a>common-api模块</h3><p><img src="https://img.neoniou.com/blog/20201218162945.png" srcset="/img/loading.gif" alt=""></p><p>用于提供一个接口</p><p><strong>SayService:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SayService</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据名字say hello</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 名字</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> name + hello</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">sayHelloByName</span><span class="hljs-params">(String name)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="service-provider"><a href="#service-provider" class="headerlink" title="service-provider"></a>service-provider</h3><p><img src="https://img.neoniou.com/blog/20201218163945.png" srcset="/img/loading.gif" alt=""></p><p>SpringBoot项目，提供实例供consumer使用</p><p><strong>pom：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-registry-nacos<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.nacos<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>nacos-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.neoniou.demo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>common-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>配置文件application.yaml：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">14511</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">provider-service</span><br>  <span class="hljs-attr">main:</span><br>    <span class="hljs-attr">allow-bean-definition-overriding:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">dubbo:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">provider-service</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">address:</span> <span class="hljs-string">nacos://127.0.0.1:8848</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">nacos</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">nacos</span><br>  <span class="hljs-attr">scan:</span><br>    <span class="hljs-attr">base-packages:</span> <span class="hljs-string">com.neoniou.provider.service.impl</span><br>  <span class="hljs-attr">protocol:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">dubbo</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">15511</span><br></code></pre></td></tr></table></figure><p><strong>ProviderApplication.class：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableDubbo</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProviderApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(ProviderApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>SayServiceImpl.class：</strong></p><p>关于这个地方，<strong>@DubboService</strong>是新版Dubbo的注解，如果是旧版比如2.7.3，使用的是<strong>org.apache.dubbo.config.annotation.Service</strong>这个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DubboService</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SayServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SayService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHelloByName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name + <span class="hljs-string">",hello!"</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="service-consumer"><a href="#service-consumer" class="headerlink" title="service-consumer"></a>service-consumer</h3><p><img src="https://img.neoniou.com/blog/20201218163928.png" srcset="/img/loading.gif" alt=""></p><p>pom和启动类同provider</p><p><strong>SayController：</strong></p><p>同上，这里的<strong>@DubboReference</strong>是一个新版注解，老版本使用的是<strong>org.apache.dubbo.config.annotation.Reference</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/demo/say"</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SayController</span> </span>&#123;<br><br>    <span class="hljs-meta">@DubboReference</span><br>    <span class="hljs-keyword">private</span> SayService sayService;<br><br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/sayHello"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">sayHello</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"name"</span>)</span> String name) </span>&#123;<br>        <span class="hljs-keyword">return</span> ResponseEntity.ok(sayService.sayHelloByName(name));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、项目启动"><a href="#4、项目启动" class="headerlink" title="4、项目启动"></a>4、项目启动</h2><p>先启动provider，再启动consumer</p><p>可以在nacos控制面板中看到：</p><p><img src="https://img.neoniou.com/blog/20201218164228.png" srcset="/img/loading.gif" alt=""></p><p><strong>测试API：</strong></p><p><img src="https://img.neoniou.com/blog/20201218164353.png" srcset="/img/loading.gif" alt=""></p><p>至此，SpringBoot+nacos+dubbo的整合就结束了，关于dubbo的配置，不仅只有yaml配置方法，还有xml、注解、bean等很多方式，可以查阅官方文档进行更适合你自己项目的配置方式。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>dubbo</tag>
      
      <tag>nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java下位运算符</title>
    <link href="/posts/java-positional-operator/"/>
    <url>/posts/java-positional-operator/</url>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><p>以前刷题，以及学计算机系统这些东西的时候经常碰到位运算符，也只是了解个大概，今天系统地学习总结了一下。</p><h2 id="1-位运算符"><a href="#1-位运算符" class="headerlink" title="1.位运算符"></a>1.位运算符</h2><p>Java下位运算符有这些：</p><h3 id="1-1-amp-与"><a href="#1-1-amp-与" class="headerlink" title="1.1 &amp; 与"></a>1.1 &amp; 与</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">int</span> num1 = <span class="hljs-number">56</span>;<br><span class="hljs-keyword">int</span> num2 = <span class="hljs-number">55</span>;<br><br>System.out.println(num1 &amp; num2);<br></code></pre></td></tr></table></figure><p>与运算下，可以把01理解为false 与 true，那么 1 &amp; 1 = 1,  1 &amp; 0 = 0,  0 &amp; 0 = 0</p><p><img src="https://neo-img.oss-cn-shanghai.aliyuncs.com/blog/jpo/jpo1.png" srcset="/img/loading.gif" alt=""></p><h3 id="1-2-或"><a href="#1-2-或" class="headerlink" title="1.2 | 或"></a>1.2 | 或</h3><p>同与运算 1 | 1 = 1, 1 | 0 = 1, 0 | 0 = 0</p><p><img src="https://neo-img.oss-cn-shanghai.aliyuncs.com/blog/jpo/jpo2.png" srcset="/img/loading.gif" alt=""></p><h3 id="1-3-取反"><a href="#1-3-取反" class="headerlink" title="1.3 ~ 取反"></a>1.3 ~ 取反</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num1 = <span class="hljs-number">56</span>;<br><br>System.out.println( ~num1 ); <span class="hljs-comment">// -57</span><br></code></pre></td></tr></table></figure><p>取反就更好理解了</p><p>1变0, 0变1</p><p><img src="https://neo-img.oss-cn-shanghai.aliyuncs.com/blog/jpo/jpo3.png" srcset="/img/loading.gif" alt=""></p><h3 id="1-4-异或"><a href="#1-4-异或" class="headerlink" title="1.4 ^ 异或"></a>1.4 ^ 异或</h3><p>只有不同才是1，相同全是1</p><p><img src="https://neo-img.oss-cn-shanghai.aliyuncs.com/blog/jpo/jpo4.png" srcset="/img/loading.gif" alt=""></p><h3 id="1-5-lt-lt-左移"><a href="#1-5-lt-lt-左移" class="headerlink" title="1.5 &lt;&lt; 左移"></a>1.5 &lt;&lt; 左移</h3><p>左移的意思是将二进制向左移多少位</p><p>例如：12(1100) &lt;&lt; 2</p><p><img src="https://neo-img.oss-cn-shanghai.aliyuncs.com/blog/jpo/jpo5.png" srcset="/img/loading.gif" alt=""></p><p>结果是：48，同样我们可以计算 12 &lt;&lt; 3 = 96, 8 &lt;&lt; 4 = 128</p><p>所以可以总结得到 <strong>M &lt;&lt; n = M * 2^n</strong></p><h3 id="1-6-gt-gt-右移"><a href="#1-6-gt-gt-右移" class="headerlink" title="1.6 &gt;&gt; 右移"></a>1.6 &gt;&gt; 右移</h3><p>右移同左移，但是在符号上有一定区别，在左移中，空余位置全部用0补齐，而在右移中，正数用0补齐，负数用1补齐</p><p>12 &gt;&gt; 2 = 3 (11)</p><p><img src="https://neo-img.oss-cn-shanghai.aliyuncs.com/blog/jpo/jpo6.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>位运算符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AX5/AX1800/AX3600 免刷机低调上网</title>
    <link href="/posts/miwifi-ss/"/>
    <url>/posts/miwifi-ss/</url>
    
    <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>最近换了一个ax5路由器，手里的k2p就可以退休了，不过ax5官方固件肯定不支持酸酸乳等功能，所以本来的准备是用k2p当单臂路由转发请求。到手后弄了一下发现怎么都不成功，遂放弃了。</p><p>今天逛论坛发现了小米wifi6系列的三款路由器都可以开SSH，那这就意味着可以自己装插件了。</p><p>clash这个东西也是今天才了解到的，使用下来感受也确实很舒服，配置什么的都很流畅。</p><p>感谢论坛dalao们的教程：</p><p><a href="https://www.right.com.cn/forum/forum.php?mod=viewthread&tid=4032490&extra=page%3D1%26filter%3Dtypeid%26typeid%3D44" target="_blank" rel="noopener">开启ssh（基础）</a></p><p><a href="https://github.com/juewuy/clash-for-Miwifi" target="_blank" rel="noopener">clash（我使用的）</a></p><p><a href="https://github.com/monlor/MIXBOX" target="_blank" rel="noopener">MixBox(可以实现一定的拓展，不过ax系列用不了饮料，所以放弃)</a></p><h2 id="1、开启-SSH"><a href="#1、开启-SSH" class="headerlink" title="1、开启 SSH"></a>1、开启 SSH</h2><p>代码：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://192.168.31.1/cgi-bin/luci/;stok=&lt;STOK&gt;/api/misystem/set_config_iotdev?bssid=Xiaomi&amp;user_id=longdike&amp;ssid=-h<span class="hljs-number">%3</span>B<span class="hljs-number">%20</span>nvram<span class="hljs-number">%20</span>set<span class="hljs-number">%20</span>ssh_en<span class="hljs-number">%3</span>D1<span class="hljs-number">%3</span>B<span class="hljs-number">%20</span>nvram<span class="hljs-number">%20</span>commit<span class="hljs-number">%3</span>B<span class="hljs-number">%20</span>sed<span class="hljs-number">%20</span>-i<span class="hljs-number">%20</span>'s<span class="hljs-number">%2</span>Fchannel<span class="hljs-number">%3</span>D.*<span class="hljs-number">%2</span>Fchannel<span class="hljs-number">%3</span>D<span class="hljs-number">%5</span>C<span class="hljs-number">%22</span>debug<span class="hljs-number">%5</span>C<span class="hljs-number">%22</span><span class="hljs-number">%2</span>Fg'<span class="hljs-number">%20</span><span class="hljs-number">%2</span>Fetc<span class="hljs-number">%2</span>Finit.d<span class="hljs-number">%2</span>Fdropbear<span class="hljs-number">%3</span>B<span class="hljs-number">%20</span><span class="hljs-number">%2</span>Fetc<span class="hljs-number">%2</span>Finit.d<span class="hljs-number">%2</span>Fdropbear<span class="hljs-number">%20</span>start<span class="hljs-number">%3</span>B<span class="hljs-number">%20</span>echo<span class="hljs-number">%20</span>-e<span class="hljs-number">%20</span>'admin<span class="hljs-number">%5</span>Cnadmin'<span class="hljs-number">%20</span><span class="hljs-number">%7</span>C<span class="hljs-number">%20</span>passwd<span class="hljs-number">%20</span>root<span class="hljs-number">%3</span>B<br></code></pre></td></tr></table></figure><p>将登陆后台后的stok代码替换链接中的<STOK>即可</p><p>SSH登陆：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">密码是admin</span><br>ssh root@192.168.31.1<br></code></pre></td></tr></table></figure><h2 id="2、下载配置-Clash"><a href="#2、下载配置-Clash" class="headerlink" title="2、下载配置 Clash"></a>2、下载配置 Clash</h2><p><a href="https://github.com/juewuy/clash-for-Miwifi" target="_blank" rel="noopener">clash github</a></p><p>按照README下载配置即可</p><p>因为我使用的是clashR，在这说一下我的配置方法</p><p><a href="https://acl4ssr.netlify.app/" target="_blank" rel="noopener">https://acl4ssr.netlify.app/</a>   在此网站复制进订阅链接，客户端选择 CalshR新参数，生成链接后访问</p><p>将 <strong>proxies</strong> 后的配置文件复制进config.yaml即可，如果直接复制全部的话会丢失一部分配置，导致Clash出错</p>]]></content>
    
    
    <categories>
      
      <category>搞机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>路由器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日校园自动签到-云函数版使用说明</title>
    <link href="/posts/auto-serverless-readme/"/>
    <url>/posts/auto-serverless-readme/</url>
    
    <content type="html"><![CDATA[<h1 id="今日校园自动签到-云函数版"><a href="#今日校园自动签到-云函数版" class="headerlink" title="今日校园自动签到-云函数版"></a>今日校园自动签到-云函数版</h1><h3 id="1、使用前"><a href="#1、使用前" class="headerlink" title="1、使用前"></a>1、使用前</h3><p><a href="https://github.com/aowubulao/auto-cpdaily/tree/serverless" target="_blank" rel="noopener">GitHub地址</a></p><p><strong>有任何问题可以联系我：<a href="mailto:me@neow.cc">me@neow.cc</a></strong></p><p>目前只适用于西南大学晨晚检签到系统</p><hr><h3 id="2、下载"><a href="#2、下载" class="headerlink" title="2、下载"></a>2、下载</h3><p><a href="https://share.neoniou.com/serverless/" target="_blank" rel="noopener">下载链接1</a></p><p>下载后请解压：</p><p>解压后目录：</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nimrod">|-<span class="hljs-built_in">auto</span>-cpdaily-serverless.jar<span class="hljs-comment">#主程序</span><br>|-daily.properties<span class="hljs-comment">#配置文件</span><br></code></pre></td></tr></table></figure><h3 id="3、配置"><a href="#3、配置" class="headerlink" title="3、配置"></a>3、配置</h3><p>右键记事本打开 <strong>daily.properties</strong> 即可</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#学号</span><br><span class="hljs-attr">username</span>=<span class="hljs-string">xxxxxxxxxxxxxxx</span><br><br><span class="hljs-comment">#密码，为身份证后六位</span><br><span class="hljs-attr">password</span>=<span class="hljs-string">123456</span><br><br><span class="hljs-comment">#打卡位置，请使用 unicode 编码填写</span><br><span class="hljs-comment">#西南大学转换为 unicode编码 为 ：\u897f\u5357\u5927\u5b66</span><br><span class="hljs-comment">#改为你自己平时定位的地址名字即可，为中文地址</span><br><span class="hljs-comment">#可以在这个网站转换编码 http://tool.chinaz.com/Tools/Unicode.aspx?qq-pf-to=pcqq.c2c</span><br><span class="hljs-attr">position</span>=<span class="hljs-string">\u897f\u5357\u5927\u5b66</span><br><br><span class="hljs-comment">#打卡地址的经纬度，保留6位小数</span><br><span class="hljs-comment">#可以在这个网站查询打卡位置的经纬度 http://api.map.baidu.com/lbsapi/getpoint/</span><br><span class="hljs-attr">longitude</span>=<span class="hljs-string">106.430691</span><br><span class="hljs-attr">latitude</span>=<span class="hljs-string">29.826659</span><br><br><span class="hljs-comment">#是否启用查寝功能，true为启用，false为不启用</span><br><span class="hljs-attr">activeAttendance</span>=<span class="hljs-string">true</span><br><br><span class="hljs-comment">#server酱的推送Key，可以将打卡结果推送到微信</span><br><span class="hljs-comment">#具体配置方法请看说明手册</span><br><span class="hljs-attr">scKey</span>=<span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h3 id="4、打包"><a href="#4、打包" class="headerlink" title="4、打包"></a>4、打包</h3><p>将配置文件打入包中</p><p>此步骤建议下载 7zip 解压软件</p><p>地址：<a href="https://www.7-zip.org/download.html" target="_blank" rel="noopener">https://www.7-zip.org/download.html</a></p><p><strong>右键 auto-cpdaily-serverless.jar</strong> 然后打开压缩包 <strong>不要解压</strong></p><p>将 <strong>daily.properties</strong> 复制进压缩包中，然后关闭</p><h3 id="5、云函数"><a href="#5、云函数" class="headerlink" title="5、云函数"></a>5、云函数</h3><h4 id="1）申请"><a href="#1）申请" class="headerlink" title="1）申请"></a>1）申请</h4><p>搜索腾讯云，进入搜索云函数，申请即可，地址：<a href="https://console.cloud.tencent.com/scf/index?rid=1" target="_blank" rel="noopener">https://console.cloud.tencent.com/scf/index?rid=1</a></p><h4 id="2）创建"><a href="#2）创建" class="headerlink" title="2）创建"></a>2）创建</h4><p>申请完成后创建（新建函数）</p><p><strong>函数名称</strong>：随便填一个</p><p><strong>运行环境</strong>：选择Java8</p><p><strong>创建方式</strong>：模板函数</p><img src="https://img.neoniou.com/readme/auto-serverless-1.png" srcset="/img/loading.gif" style="zoom:80%;" /><p>然后点击下一步，此时有一个高级设置，展开高级设置，将<strong>超时时间</strong>设置为20s</p><p>内存建议设置为256MB或更高</p><img src="https://img.neoniou.com/readme/auto-serverless-2.png" srcset="/img/loading.gif" style="zoom: 80%;" /><p>点击<strong>完成</strong>即创建成功</p><h4 id="3）上传文件"><a href="#3）上传文件" class="headerlink" title="3）上传文件"></a>3）上传文件</h4><p>打开刚才创建的函数，在<strong>函数管理</strong>的<strong>函数代码</strong>中</p><p><strong>提交方法</strong>：本地上传Zip包</p><p><strong>执行方法</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">daily</span><span class="hljs-selector-class">.AutoDailyCp</span><span class="hljs-selector-pseudo">::mainHandler</span><br></code></pre></td></tr></table></figure><p>点击上传，将刚才打包好的文件上传至网页，最后点击<strong>保存</strong></p><img src="https://img.neoniou.com/readme/auto-serverless-3.png" srcset="/img/loading.gif" style="zoom: 80%;" /><h4 id="4）设置定时任务"><a href="#4）设置定时任务" class="headerlink" title="4）设置定时任务"></a>4）设置定时任务</h4><p>触发管理中，创建触发器，建议设置为：（如图）</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">9</span>,<span class="hljs-number">20</span> * * * *<br></code></pre></td></tr></table></figure><p>这个表示每天9点，20点运行一次，具体时间可以根据学院的打卡时间修改一下</p><p>最后<strong>提交</strong>即可。</p><p><img src="https://img.neoniou.com/blog/20201225110651.png" srcset="/img/loading.gif" alt=""></p><h4 id="5）日志查询"><a href="#5）日志查询" class="headerlink" title="5）日志查询"></a>5）日志查询</h4><p>可以在日志查询处查询运行状态和运行日志。</p><h3 id="6、配置-Server酱推送"><a href="#6、配置-Server酱推送" class="headerlink" title="6、配置 Server酱推送"></a>6、配置 Server酱推送</h3><p>server 酱可以将打卡结果推送到微信</p><p>Server酱地址：<a href="http://sc.ftqq.com/3.version" target="_blank" rel="noopener">http://sc.ftqq.com/3.version</a></p><p><img src="https://img.neoniou.com/blog/20201229131510.png" srcset="/img/loading.gif" alt=""></p><p>根据Server酱的步骤完成前两步，点击发送消息</p><p><img src="https://img.neoniou.com/blog/20201229131625.png" srcset="/img/loading.gif" alt=""></p><p>将key复制到配置文件中即可</p><p><img src="https://img.neoniou.com/blog/20201229132710.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>README</category>
      
    </categories>
    
    
    <tags>
      
      <tag>云函数</tag>
      
      <tag>今日校园</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ssl pinning下的安卓免root抓包</title>
    <link href="/posts/andriod-noroot-cap/"/>
    <url>/posts/andriod-noroot-cap/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在研究安卓的App如何抓包，一开始想的很简单，以为就和浏览器F12里那样简单，所以直接搜了一个号称免root抓包的App到手机上。打开后发现应用都不能联网了。以为是软件的问题，遂百度了一番，开始用fiddler4抓包——结果还是，应用都没有网了。</p><h2 id="Ssl-Pinning"><a href="#Ssl-Pinning" class="headerlink" title="Ssl Pinning"></a>Ssl Pinning</h2><p>然后又是一阵的搜索，发现是Ssl Pinning搞的鬼，如果熟悉https的话，应该知道CA证书吧，用于检验请求双方的身份，防止中间人攻击。在抓包的时候，通常会在手机中设置一个代理，安装代理的证书，但这个证书是不被应用信任的，通过代理时，应用就不会发出请求，从而导致了没有网络的情况。</p><h2 id="Virtual-Xposed"><a href="#Virtual-Xposed" class="headerlink" title="Virtual Xposed"></a>Virtual Xposed</h2><p>现在问题的关键在于如何绕开Ssl Pinning的干扰，一个成熟的办法是手机root安装xposed模块+just trust me，可以在不被信任的情况下强制绕过，发出请求。</p><p>不过现在手机root都很麻烦，我试了一下用安装模拟器运行应用，但是很多应该在模拟器上都不能很好的运行甚至闪退。</p><p>这时候我发现了<a href="https://vxposed.com/" target="_blank" rel="noopener">Virtual Xposed</a>这个神器。一个虚拟的沙箱，自带一个root环境+xposed框架，软件也是轻量级的。</p><p>最后使用的模块是virtual xposed + trust me already，同时将要抓包的应用导入vx当中，运行，外部再使用Fiddler4抓包就ok了。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安卓</tag>
      
      <tag>抓包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java线程池的创建方法</title>
    <link href="/posts/java-threadpool/"/>
    <url>/posts/java-threadpool/</url>
    
    <content type="html"><![CDATA[<h2 id="1、自动创建（不推荐）"><a href="#1、自动创建（不推荐）" class="headerlink" title="1、自动创建（不推荐）"></a>1、自动创建（不推荐）</h2><p>在Java8以后，线程池的创建方法有5种，这里介绍3种常用的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>ExecutorService threadPool = Executors.newSingleThreadExecutor();<br>ExecutorService threadPool = Executors.newCachedThreadPool();<br></code></pre></td></tr></table></figure><p>第一种是创建一个定容的线程池；</p><p>第二种是创建一个只有一个线程容量的线程池；</p><p>第三种是创建一个带缓存可扩容的线程池。</p><p>但是在使用时，阿里的代码检测工具会提示手动建立线程池。看一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<br>                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                      <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService<br>            (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                    <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p>三种方法底层其实都是使用了new ThreadPoolExecutor的方式创建线程池，第三种的最大线程容量甚至达到了Integer.MAX_VALUE，如果允许线程池无限扩容的话，会创建非常多的线程。而前两种的主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。</p><p>所以如何手动创建线程池是我们需要学习的。</p><h2 id="手动创建线程池"><a href="#手动创建线程池" class="headerlink" title="手动创建线程池"></a>手动创建线程池</h2><p>我们可以通过new ThreadPoolExecutor的方式手动创建线程池，首先我们要了解构造方法的七个参数的具体含义。</p><p>直接看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-function"><span class="hljs-params">    TimeUnit unit,</span></span><br><span class="hljs-function"><span class="hljs-params">    BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-function"><span class="hljs-params">    ThreadFactory threadFactory,</span></span><br><span class="hljs-function"><span class="hljs-params">    RejectedExecutionHandler handler)</span></span><br></code></pre></td></tr></table></figure><p>corePoolSize：线程池中的常驻核心数线程；</p><p>maximumPoolSize：线程池能够容纳的同时执行的最大线程数；</p><p>keepAliveTime：多余的线程的存活时间；</p><p>unit：对keepAliveTime 的时间单位；</p><p>workQueue：任务队列，被提交但尚未被执行的任务；</p><p>threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程；</p><p>handler：拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorService threadPool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>,<br>            <span class="hljs-number">5</span>,<br>            <span class="hljs-number">1L</span>,<br>            TimeUnit.SECONDS,<br>            <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">3</span>),<br>            Executors.defaultThreadFactory(),<br>            <span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy());<br></code></pre></td></tr></table></figure><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>定义：等待队列也已经排满了，再也塞不下新的任务了同时，线程池的max也到达了，无法接续为新任务服务这时我们需要拒绝策略机制合理的处理这个问题。</p><p>JDK内置的拒绝策略：</p><ul><li><p>AbortPolicy(默认): 直接抛出RejectedException异常，阻止系统正常运行；</p></li><li><p>CallerRunPolicy:  不会抛异常，也不会抛弃任务，而是会将某些任务回退到调用它的线程。</p><p>如：main调用了thread-pool-0计算1+1，而此时线程池已满，启动拒绝策略，会将这个任务返还给main线程，让main线程执行计算；</p></li><li><p>DiscardOldestPolicy: 抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交；</p></li><li><p>DiscardPolicy: 直接抛弃任务，不予任何处理，也不抛出异常。如果允许任务丢失，这是最好的方法。</p></li></ul><h3 id="合理配置线程池的容量"><a href="#合理配置线程池的容量" class="headerlink" title="合理配置线程池的容量"></a>合理配置线程池的容量</h3><p>如何合理配置线程池？</p><h4 id="CPU密集型"><a href="#CPU密集型" class="headerlink" title="CPU密集型"></a>CPU密集型</h4><p>CPU密集的意思是该任务需要大量的计算，而没有阻塞，CPU一直进行计算；</p><p>一般公式：CPU核数+1个线程的线程池。</p><h4 id="I-O密集型"><a href="#I-O密集型" class="headerlink" title="I/O密集型"></a>I/O密集型</h4><p>IO密集型不需要大量计算，而需要进行大量IO操作阻塞。</p><p>IO密集型，大多线程都会阻塞，所以需要尽可能多的线程：</p><ul><li>CPU核数 / (1 - 阻塞系数) 阻塞系数在0.8-0.9之间</li><li>CPU核数 * 2</li></ul><p>两种公式视场合使用。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java由volatile深入的一些问题</title>
    <link href="/posts/volatile/"/>
    <url>/posts/volatile/</url>
    
    <content type="html"><![CDATA[<h2 id="JMM-Java-Memety-Model-Java内存模型"><a href="#JMM-Java-Memety-Model-Java内存模型" class="headerlink" title="JMM(Java Memety Model) Java内存模型"></a>JMM(Java Memety Model) Java内存模型</h2><p>首先了解一下JMM，JMM本身是一种抽象的概念，描述的是一组规范。</p><h5 id="JMM关于同步的规范"><a href="#JMM关于同步的规范" class="headerlink" title="JMM关于同步的规范"></a>JMM关于同步的规范</h5><ol><li>线程解锁前，必须把共享变量的值刷新回主线程；</li><li>线程加锁前，必须把主内存的最新值读取到自己的工作内存；</li><li>加锁解锁是同一把锁。</li></ol><h5 id="JMM要求"><a href="#JMM要求" class="headerlink" title="JMM要求"></a>JMM要求</h5><ol><li>可见性</li><li>原子性</li><li>有序性</li></ol><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>有序性是指在单线程环境中, 程序是按序依次执行的。而在多线程环境中, 程序的执行可能因为指令重排而出现乱序。</p><p><strong>知识点：</strong></p><ul><li>内存可见性</li><li>主存与线程之间内存的联系</li></ul><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>volatile是java提供的轻量级的同步机制。</p><ul><li>保证可见性</li><li>不保证原子性</li><li>禁止指令重排</li></ul><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>原子性就是说一个操作不可以被CPU中途暂停然后调度，即不能被中断，要不就执行完， 要不就不执行。 如果一个操作是原子性的，那么在多线程环境下，就不会出现变量被修改等奇怪的问题。</p><h5 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h5><p>volatile实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象。保证多线程间的语义一致性。</p><p>实现方法：使用CPU内存屏障（Memery Barrier），在指令中插入一条Memery Barrier指令，会告诉编译器和CPU，禁止重排。</p><p>也就是说，通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。</p><p>内存屏障的另一个作用就是强制刷新各种CPU的缓存数据，因此CPU上的任何线程都能读取到这些数据的最新版本。(可见性保证)</p><p>单例模式中，DCL双锁就使用了volatile防止多线程下指令被重排。</p><h5 id="volatile的使用方式"><a href="#volatile的使用方式" class="headerlink" title="volatile的使用方式"></a>volatile的使用方式</h5><p>（不做具体介绍）</p><h3 id="为什么volatile不保证原子性？"><a href="#为什么volatile不保证原子性？" class="headerlink" title="为什么volatile不保证原子性？"></a>为什么volatile不保证原子性？</h3><h2 id="CAS底层实现原理"><a href="#CAS底层实现原理" class="headerlink" title="CAS底层实现原理"></a>CAS底层实现原理</h2><p>关键词：unsafe</p><p>在volatile中，因为不保证原子性，所以在多线程下是不安全的，需要通过CAS实现原子性。</p><p><strong>CAS：Compare and swap，比较并交换。</strong></p><p>第一步，在线程从主存读取一个值 V=5 后，会暂存这个 V 为 A，称为旧的预期值，再将 A 进行修改，假设将 A + 1，这时候使用 B = A + 1进行修改，B称为更新值。</p><p>第二步将 B 这个值赋值给主存的V时，会先进行比较，如果主存中的这个V还==旧预期值A，那么说明这个V是没有被操作过的，那么就可以进行数值的更新 V=B；但是如果此时 V ≠ A，说明这个值已经被修改了，那么线程将会返回，重新执行 V+1的操作，直到这个过程成功。</p><p>这就是CAS的基本实现过程。</p><h3 id="CAS源码实现"><a href="#CAS源码实现" class="headerlink" title="CAS源码实现"></a>CAS源码实现</h3><p>为什么CAS能实现原子性？靠的是底层的Unsafe类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-keyword">this</span>, valueOffset, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为Java无法和操作系统底层进行交互，需要通过本地方法（native）来访问。Unsafe存在于sum.misc包中，其内部方法可以直接操作特定内存的数据，像C的指针一样直接操作内存。</p><p>注：Unsafe中所以方法都是native修饰的，也就是说Unsafe类中的方法都调用操作系统的底层资源执行相应任务。</p><p>变量<strong>valueOffset</strong>，表示该变量在内存中的偏移地址</p><p><strong>CAS的功能判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。</strong></p><p>同时，因为比较并交换是系统原语，所以不会造成数据不一致的现象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">int</span> var4)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> var5;<br>    <span class="hljs-keyword">do</span> &#123;<br>        var5 = <span class="hljs-keyword">this</span>.getIntVolatile(var1, var2);<br>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<br><br>    <span class="hljs-keyword">return</span> var5;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h3><ul><li>如果一直不成功，会给CPU带来很大开销；</li><li>只能保证一个变量的原子性操作；</li><li>会引发BAB问题。</li></ul><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>此时：主存中值为A，线程1和线程2取出A，线程2将A改为B并写回主存，然后又将B改为A写回主存，主存中的值由A-&gt;B-&gt;A，改变了两次，之后才线程1修改了A，将值传回主存，发现值没变，成功写入。</p><p>尽管线程1操作成功，但这个过程也是存在问题的。</p><h4 id="如何解决ABA问题？"><a href="#如何解决ABA问题？" class="headerlink" title="如何解决ABA问题？"></a>如何解决ABA问题？</h4><p>带时间戳的原子引用</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java单例</title>
    <link href="/posts/java-singleton/"/>
    <url>/posts/java-singleton/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>单例设计模式，即某个类在整个系统中只能有一个实例对象可被获取和使用的代码模式。</p><p>1、单例类只能有一个实例。</p><p>2、单例类必须自己创建自己的唯一实例。</p><p>3、单例类必须给所有其他对象提供这一实例。</p><p><strong>优点：</strong></p><p>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。</p><p>2、避免对资源的多重占用。</p><p><strong>缺点：</strong></p><p>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p><strong>使用场景：</strong></p><p>1、要求生产唯一序列号。</p><p>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</p><p>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p><h3 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h3><p>创建一个Singleton类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo1</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建实例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonDemo1 instance = <span class="hljs-keyword">new</span> SingletonDemo1();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造方法私有化，这样该类就不会被实例化</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo1</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回实例，获取唯一可用对象</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> SingletonDemo1 instance</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo1 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"Hello SingletonDemo1 !"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h3><p>从SingletonDemo1中获取唯一对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonMainDemo1</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        SingletonDemo1 instance = SingletonDemo1.getInstance();<br>        <br>        instance.sayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h3><p>控制台输出</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Hello SingletonDemo1 !<br></code></pre></td></tr></table></figure><hr><h2 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h2><h3 id="1、懒汉式，线程不安全"><a href="#1、懒汉式，线程不安全" class="headerlink" title="1、懒汉式，线程不安全"></a>1、懒汉式，线程不安全</h3><p>是否 Lazy 初始化：是</p><p>是否多线程安全：否</p><p>实现难度：易</p><p>描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</p><p>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;  <br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;  <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;<br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;  <br>            instance = <span class="hljs-keyword">new</span> Singleton();  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> instance;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。</strong></p><h3 id="2、懒汉式，线程安全"><a href="#2、懒汉式，线程安全" class="headerlink" title="2、懒汉式，线程安全"></a>2、懒汉式，线程安全</h3><p>是否 Lazy 初始化：是</p><p>是否多线程安全：是</p><p>实现难度：易</p><p>描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。</p><p>优点：第一次调用才初始化，避免内存浪费。</p><p>缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;  <br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;  <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;<br>    &#125;  <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;  <br>            instance = <span class="hljs-keyword">new</span> Singleton();  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> instance;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、饿汉式"><a href="#3、饿汉式" class="headerlink" title="3、饿汉式"></a>3、饿汉式</h3><p>是否 Lazy 初始化：否</p><p>是否多线程安全：是</p><p>实现难度：易</p><p>描述：这种方式比较常用，但容易产生垃圾对象。</p><p>优点：没有加锁，执行效率会提高。</p><p>缺点：类加载时就初始化，浪费内存。</p><p>它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;  <br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();  <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;<br>    &#125;  <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> instance;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#4、双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="4、双检锁/双重校验锁（DCL，即 double-checked locking）"></a>4、双检锁/双重校验锁（DCL，即 double-checked locking）</h3><p>JDK 版本：JDK1.5 起</p><p>是否 Lazy 初始化：是</p><p>是否多线程安全：是</p><p>实现难度：较复杂</p><p>描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</p><p>getInstance() 的性能对应用程序很关键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;  <br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton singleton;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;<br>    &#125;  <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;  <br>            <span class="hljs-keyword">synchronized</span> (Singleton<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;  <br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;  <br>                    singleton = <span class="hljs-keyword">new</span> Singleton();  <br>                &#125;  <br>         &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> singleton;  <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、登记式-静态内部类"><a href="#5、登记式-静态内部类" class="headerlink" title="5、登记式/静态内部类"></a>5、登记式/静态内部类</h3><p>是否 Lazy 初始化：是</p><p>是否多线程安全：是</p><p>实现难度：一般</p><p>描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p><p>这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。</p><p>因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;  <br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();  <br>    &#125;  <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;<br>    &#125;  <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、枚举"><a href="#6、枚举" class="headerlink" title="6、枚举"></a>6、枚举</h3><p>JDK 版本：JDK1.5 起</p><p>是否 Lazy 初始化：否</p><p>是否多线程安全：是</p><p>实现难度：易</p><p>描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。</p><p>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 Enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。</p><p>不能通过 reflection attack 来调用私有构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Singleton &#123;<br>    <br>    INSTANCE;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whateverMethod</span><span class="hljs-params">()</span> </span>&#123; <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap小结</title>
    <link href="/posts/HashMap/"/>
    <url>/posts/HashMap/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap小结"><a href="#HashMap小结" class="headerlink" title="HashMap小结"></a>HashMap小结</h1><ol><li>HashMap是基于哈希表实现的，每一个元素是一个key-value对，其内部通过单链表解决冲突问题，具有自动扩容机制。且key-value可为null。</li><li>HashMap是线程不安全的。</li><li>HashMap 实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆。</li><li>在jdk1.8之前，HashMap采用<strong>数组+链表</strong>的储存方式。从jdk1.8开始，HashMap采用<strong>数组+链表/红黑树</strong>的储存方式。在阈值大于8且数组长度大于64时，链表会转换为红黑树的形式，以此提高HashMap的搜索效率。</li><li>当链表长度&gt;64以及链表长度&gt;8时，链表将转化为红黑树。当红黑树结点小于6时，再转换为链表。</li></ol><h2 id="1、HashMap的储存过程"><a href="#1、HashMap的储存过程" class="headerlink" title="1、HashMap的储存过程"></a>1、HashMap的储存过程</h2><p>首先来看一下HashMap的储存过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;String, String&gt; hashMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>hashMap.put(<span class="hljs-string">"Aa"</span>, <span class="hljs-string">"19"</span>);<br>hashMap.put(<span class="hljs-string">"Cc"</span>, <span class="hljs-string">"17"</span>);<br>hashMap.put(<span class="hljs-string">"BB"</span>, <span class="hljs-string">"20"</span>);<br>hashMap.put(<span class="hljs-string">"Aa"</span>, <span class="hljs-string">"30"</span>);<br></code></pre></td></tr></table></figure><p><img src="https://img.neoniou.com/md/mianshi/image-20200318164927987.png" srcset="/img/loading.gif" alt="image-20200318164927987"></p><p>整个储存过程如下：</p><ol><li>开辟数组空间（默认16）</li><li>通过位运算计算”Aa”的Hash值及对应的索引，存储Aa-19</li><li>同上，存储Cc-17</li><li>当存储BB时，计算发现索引已经储存了键值对，发生Hash碰撞，再调用euqals方法，计算发现不相等，所以便通过链表储存BB-20</li><li>最后Aa-20，计算HashCode以及euqals都相同，则覆盖先前的值。</li></ol><h4 id="问题1：HashMap底层通过什么方式计算Hash值？还有哪些方法可以用于计算Hash值？"><a href="#问题1：HashMap底层通过什么方式计算Hash值？还有哪些方法可以用于计算Hash值？" class="headerlink" title="问题1：HashMap底层通过什么方式计算Hash值？还有哪些方法可以用于计算Hash值？"></a>问题1：HashMap底层通过什么方式计算Hash值？还有哪些方法可以用于计算Hash值？</h4><p>HashMap底层采用位运算计算，还可以通过伪随机数和取余进行计算。（取余在计算机底层效率很低，所以不使用）</p><h4 id="问题2：什么是Hash碰撞，如何解决？"><a href="#问题2：什么是Hash碰撞，如何解决？" class="headerlink" title="问题2：什么是Hash碰撞，如何解决？"></a>问题2：什么是Hash碰撞，如何解决？</h4><p>不同的键计算Hash值索引相同即会产生Hash碰撞，通过链表+红黑树的方法解决。</p><h2 id="2、HashMap的成员变量"><a href="#2、HashMap的成员变量" class="headerlink" title="2、HashMap的成员变量"></a>2、HashMap的成员变量</h2><h3 id="2-1、默认容量"><a href="#2-1、默认容量" class="headerlink" title="2.1、默认容量"></a>2.1、默认容量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The default initial capacity - MUST be a power of two.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br></code></pre></td></tr></table></figure><p>HashMap默认容量为16，且容量必须是2的n次幂。即使赋值不是2的n次幂，在底层也会转换为2的n次幂。</p><p><strong>举个栗子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;String, String&gt; hashMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>在底层10会变为比它大的最小的2的n次幂：10-&gt;16。以此类推7-&gt;8。</p><h4 id="问题3：为什么HashMap容量必须是2的n次幂？"><a href="#问题3：为什么HashMap容量必须是2的n次幂？" class="headerlink" title="问题3：为什么HashMap容量必须是2的n次幂？"></a>问题3：为什么HashMap容量必须是2的n次幂？</h4><p>为了减少Hash碰撞。</p><p>HashMap采用位运算：&gt;&gt;&gt; ^ &amp;计算Hash值。这个算法本质就是取模，hash%length，源码中进行了优化，使用hash&amp;(length-1)进行计算，而hash%length等于hash&amp;(length-1)的前提是数组长度为2的n次幂。</p><p><strong>举个栗子</strong>：</p><hr><p>数组长度为8</p><p>hash值：        3    00000011</p><p>length-1:         7    00000111，位运算结果：00000011，即索引为 3</p><p>hash值：        2    00000010</p><p>length-1:         7    00000110，位运算结果：00000011，即索引为 2</p><p>不会产生hash碰撞</p><hr><p>数组长度为9</p><p>hash值：        3    00000011</p><p>length-1:         8    00001000，位运算结果：00000000，即索引为 0</p><p>hash值：        2    00000010</p><p>length-1:         8    00001000，位运算结果：00000000，即索引为 0</p><p>产生hash碰撞</p><h3 id="2-2、负载因子"><a href="#2-2、负载因子" class="headerlink" title="2.2、负载因子"></a>2.2、负载因子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The load factor used when none specified in constructor.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br></code></pre></td></tr></table></figure><p>HashMap负载因子为0.75</p><p><strong>什么是负载因子？</strong>HashMap默认容量为16，当储存达到16*0.75=12时，便会执行扩容操作</p><p>threshold = capacity（默认长度16） * loadFactory（默认负载因子0.75）。这个值是是当前已经占用的数组长度的最大值，当size &gt;= threshold时，便会执行扩容。</p><h4 id="问题4：为什么负载因子设置为0-75？"><a href="#问题4：为什么负载因子设置为0-75？" class="headerlink" title="问题4：为什么负载因子设置为0.75？"></a>问题4：为什么负载因子设置为0.75？</h4><p>如果负载因子过小，则数组利用率会降低，加载因子过大，链表数量又会过多。所以兼顾利用率和链表长度，0.75是一个衡量后比较平衡的值。</p><h3 id="2-3、红黑树链表转换"><a href="#2-3、红黑树链表转换" class="headerlink" title="2.3、红黑树链表转换"></a>2.3、红黑树链表转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><p>链表长度为8时：链表-&gt;红黑树，红黑树结点减少到6：红黑树-&gt;链表。</p><h4 id="问题5：为什么链表长度为8时转换为红黑树？"><a href="#问题5：为什么链表长度为8时转换为红黑树？" class="headerlink" title="问题5：为什么链表长度为8时转换为红黑树？"></a>问题5：为什么链表长度为8时转换为红黑树？</h4><p>根据泊松分布，HashMap中链表长度从0-&gt;8的概率是：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">0</span>:    <span class="hljs-number">0.60653066</span><br><span class="hljs-number">1</span>:    <span class="hljs-number">0.30326533</span><br><span class="hljs-number">2</span>:    <span class="hljs-number">0.07581633</span><br><span class="hljs-number">3</span>:    <span class="hljs-number">0.01263606</span><br><span class="hljs-number">4</span>:    <span class="hljs-number">0.00157952</span><br><span class="hljs-number">5</span>:    <span class="hljs-number">0.00015795</span><br><span class="hljs-number">6</span>:    <span class="hljs-number">0.00001316</span><br><span class="hljs-number">7</span>:    <span class="hljs-number">0.00000094</span><br><span class="hljs-number">8</span>:    <span class="hljs-number">0.00000006</span><br></code></pre></td></tr></table></figure><p>因为红黑树占用的内存空间是链表的两倍，链表长度达到8已经是很小的概率，从而为了增加查找速度，才转换为红黑树。</p><p>红黑树平均查找复杂度是Log(n)，如果长度为8，Log(8)=3，链表的平均查找复杂度是n/2，长度为8时，8/2=4；这才有转换为红黑树的必要。</p><h2 id="2、HashMap的成员方法"><a href="#2、HashMap的成员方法" class="headerlink" title="2、HashMap的成员方法"></a>2、HashMap的成员方法</h2><h3 id="2-1-put方法"><a href="#2-1-put方法" class="headerlink" title="2.1 put方法"></a>2.1 put方法</h3><p>put方法步骤分为以下几步：</p><ol><li><p>首先通过hash值计算key应该映射到哪个索引；</p></li><li><p>如果索引没有hash碰撞，那么直接插入key-value；</p></li><li><p>如果出现碰撞，则需要进行处理：</p><p>a)已经使用红黑树，那么使用红黑树方法插入；</p><p>b)反之则使用链表插入，若达到临界值则转换为红黑树；</p></li><li><p>如果存在重复的key，那么则覆盖value；</p></li><li><p>如果size &gt;= threshold，则执行扩容操作。</p></li></ol><h2 id="3、一些问题"><a href="#3、一些问题" class="headerlink" title="3、一些问题"></a>3、一些问题</h2><h4 id="问题6：HashMap和HashTable的区别"><a href="#问题6：HashMap和HashTable的区别" class="headerlink" title="问题6：HashMap和HashTable的区别"></a>问题6：HashMap和HashTable的区别</h4><ol><li><p>继承父类不同；</p></li><li><p>线程安全性不同，HashMap线程不安全，HashTable线程安全；</p></li><li><p>contains方法有区别，HashMap去掉了contains方法，改为containsKey和containsValue；</p></li><li><p>在HashMap中，key-value都支持null值，HashTable中则不支持；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><p>HashMap通过将null值的key转换为0从而达到储存null值的key-value，而HashTable中则没有这个转换过程。</p></li><li><p>hash值不同。HashMap会重新计算hash值，HashTable则直接调用hashCode()方法；</p></li></ol><h4 id="问题7：HashMap如何实现线程安全？"><a href="#问题7：HashMap如何实现线程安全？" class="headerlink" title="问题7：HashMap如何实现线程安全？"></a>问题7：HashMap如何实现线程安全？</h4><ol><li>使用ConcurrentHashMap</li><li>使用synchronizedMap()方法包装 HashMap，得到线程安全的Map，并在此Map上进行操作。</li></ol>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Java+阿里云oss搭建图床 后台</title>
    <link href="/posts/java-oss-img/"/>
    <url>/posts/java-oss-img/</url>
    
    <content type="html"><![CDATA[<hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> neo.zzj</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImgService</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Allow upload type (image)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; ALLOW_TYPE = Arrays.asList(<span class="hljs-string">"image/jpeg"</span>, <span class="hljs-string">"image/png"</span>, <span class="hljs-string">"image/bmp"</span>);<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * oss information</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String endpoint;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String accessKeyId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String accessKeySecret;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String bucketName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String key;<br>    <span class="hljs-keyword">static</span> &#123;<br>        Properties props = <span class="hljs-keyword">new</span> Properties();<br>        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(<span class="hljs-string">"oss.properties"</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            props.load(is);<br>            endpoint = props.getProperty(<span class="hljs-string">"endpoint"</span>);<br>            accessKeyId = props.getProperty(<span class="hljs-string">"accessKeyId"</span>);<br>            accessKeySecret = props.getProperty(<span class="hljs-string">"accessKeySecret"</span>);<br>            bucketName = props.getProperty(<span class="hljs-string">"bucketName"</span>);<br>            key = props.getProperty(<span class="hljs-string">"key"</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (<br>                IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Upload img to aliyun oss</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file Image</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Img url</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">uploadImg</span><span class="hljs-params">(MultipartFile file)</span> </span>&#123;<br>        <span class="hljs-comment">// Check file</span><br>        checkFile(file);<br>        OSS ossClient = <span class="hljs-keyword">new</span> OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);<br>        InputStream inputStream = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            String fileName = file.getOriginalFilename();<br>            String name = fileName.substring(<span class="hljs-number">0</span>, fileName.lastIndexOf(<span class="hljs-string">"."</span>));<br>            String prefix = fileName.substring(fileName.lastIndexOf(<span class="hljs-string">"."</span>));<br>            <span class="hljs-comment">// Check img is exist and rename</span><br>            <span class="hljs-keyword">boolean</span> found;<br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                found = ossClient.doesObjectExist(bucketName, fileName);<br>                <span class="hljs-keyword">if</span> (found) &#123;<br>                    fileName = name + <span class="hljs-string">"("</span> + i + <span class="hljs-string">")"</span> + prefix;<br>                    i += <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// Transfer type to file and upload</span><br>            <span class="hljs-keyword">final</span> File tempFile = File.createTempFile(UUID.randomUUID().toString().replace(<span class="hljs-string">"-"</span>,<span class="hljs-string">""</span>), prefix);<br>            file.transferTo(tempFile);<br>            inputStream = <span class="hljs-keyword">new</span> FileInputStream(tempFile);<br>            ossClient.putObject(bucketName, fileName, inputStream);<br>            <span class="hljs-comment">// Return img url</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"https://img.neoniou.com/"</span> + fileName;<br>        &#125; <span class="hljs-keyword">catch</span> (OSSException oe) &#123;<br>            System.out.println(<span class="hljs-string">"Caught an OSSException, which means your request made it to OSS, "</span><br>                    + <span class="hljs-string">"but was rejected with an error response for some reason."</span>);<br>            System.out.println(<span class="hljs-string">"Error Message: "</span> + oe.getErrorMessage());<br>            System.out.println(<span class="hljs-string">"Error Code:       "</span> + oe.getErrorCode());<br>            System.out.println(<span class="hljs-string">"Request ID:      "</span> + oe.getRequestId());<br>            System.out.println(<span class="hljs-string">"Host ID:           "</span> + oe.getHostId());<br>        &#125; <span class="hljs-keyword">catch</span> (ClientException ce) &#123;<br>            System.out.println(<span class="hljs-string">"Caught an ClientException, which means the client encountered "</span><br>                    + <span class="hljs-string">"a serious internal problem while trying to communicate with OSS, "</span><br>                    + <span class="hljs-string">"such as not being able to access the network."</span>);<br>            System.out.println(<span class="hljs-string">"Error Message: "</span> + ce.getMessage());<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">assert</span> inputStream != <span class="hljs-keyword">null</span>;<br>                inputStream.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            ossClient.shutdown();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Check file type and content</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file MultipartFile file</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkFile</span><span class="hljs-params">(MultipartFile file)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Check file type</span><br>            String contentType = file.getContentType();<br>            <span class="hljs-keyword">if</span> (!ALLOW_TYPE.contains(contentType)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NeoException(ExceptionEnum.INVALID_FILE_TYPE);<br>            &#125;<br>            <span class="hljs-comment">// Check file content</span><br>            BufferedImage image = ImageIO.read(file.getInputStream());<br>            <span class="hljs-keyword">if</span> (image == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NeoException(ExceptionEnum.INVALID_FILE_TYPE);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Delete temp file</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> files files</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteTempFile</span><span class="hljs-params">(File... files)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (File file : files) &#123;<br>            <span class="hljs-keyword">if</span> (file.exists()) &#123;<br>                file.delete();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用NProgress、axios拦截器做一个网页加载进度条</title>
    <link href="/posts/nprogress/"/>
    <url>/posts/nprogress/</url>
    
    <content type="html"><![CDATA[<p>写前端的时候，想写一个顶部的进度条功能，然后就找到了NProgress。加上axios的拦截器，可以很方便的做一个顶部进度条的样式。</p><h3 id="1、安装-Nprogress"><a href="#1、安装-Nprogress" class="headerlink" title="1、安装 Nprogress"></a>1、安装 Nprogress</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> nprogress <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h3 id="2、创建aixos-js文件"><a href="#2、创建aixos-js文件" class="headerlink" title="2、创建aixos.js文件"></a>2、创建aixos.js文件</h3><p>写入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span><br><span class="hljs-keyword">import</span> NProgress <span class="hljs-keyword">from</span> <span class="hljs-string">"nprogress"</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">'nprogress/nprogress.css'</span><br><br>axios.interceptors.request.use(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>        NProgress.inc();<br>        <span class="hljs-keyword">return</span> config;<br>    &#125;, error =&gt; &#123;<br>        NProgress.done();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error)<br>    &#125;<br>)<br>axios.interceptors.response.use(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        NProgress.done();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;, error =&gt; &#123;<br>        NProgress.done();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error)<br>    &#125;<br>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    NProgress<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、在main-js中引入"><a href="#3、在main-js中引入" class="headerlink" title="3、在main.js中引入"></a>3、在main.js中引入</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">"./plugins/axios"</span>;<br>...<br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>    ...<br>    axios,<br>    ...<br>    render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App)<br>&#125;).$mount(<span class="hljs-string">'#app'</span>)<br></code></pre></td></tr></table></figure><h3 id="4、修改样式"><a href="#4、修改样式" class="headerlink" title="4、修改样式"></a>4、修改样式</h3><p>如果需要修改进度条样式，可以把nprogress.css提取出来，然后引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">'../../src/assets/css/nprogress.css'</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Axios</tag>
      
      <tag>NProgress</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Vue项目优化首页打开速度</title>
    <link href="/posts/fast-vue-index/"/>
    <url>/posts/fast-vue-index/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>最近部署了一个Vue项目，但在测试时发现打开首页后，会花费很久的时间去加载CSS和JS文件，打开需要10s+。 所以寻找了一些优化方法。</strong></p></blockquote><h3 id="一、Vue-router懒加载"><a href="#一、Vue-router懒加载" class="headerlink" title="一、Vue router懒加载"></a>一、Vue router懒加载</h3><p>懒加载前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> Login from <span class="hljs-string">"../components/Login.vue"</span><br><span class="hljs-keyword">const</span> routes = [<br>  &#123; path: <span class="hljs-string">'/login'</span>, component: Login, meta: &#123; title: <span class="hljs-string">'登录'</span> &#125;,&#125;<br>]<br></code></pre></td></tr></table></figure><p>修改为懒加载后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Login = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../components/Login.vue'</span>)<br><span class="hljs-keyword">const</span> routes = [<br>  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/login'</span>, <span class="hljs-attr">component</span>: Login, <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'登录'</span> &#125;,&#125;<br>]<br></code></pre></td></tr></table></figure><p>这种方法虽然可以把CSS和JS文件打包为很多个，但是vender文件依然很大。 </p><p>懒加载方法比较适用于部分非首页页面过大的问题。</p><h3 id="二、组件CDN加载"><a href="#二、组件CDN加载" class="headerlink" title="二、组件CDN加载"></a>二、组件CDN加载</h3><p>我的项目使用了Vue + element等。 如果把这些组件通过CDN加载，而不是打包为项目的文件，将会大大减小vender文件大小。</p><h4 id="1、在vue-config-js中设置"><a href="#1、在vue-config-js中设置" class="headerlink" title="1、在vue.config.js中设置"></a>1、在vue.config.js中设置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">/* 设置不打包 */</span><br>  configureWebpack: &#123;<br>    externals: &#123;<br>      <span class="hljs-string">'vue'</span>: <span class="hljs-string">'Vue'</span>,<br>      <span class="hljs-string">'vue-router'</span>: <span class="hljs-string">'VueRouter'</span>,<br>      <span class="hljs-string">'element-ui'</span>: <span class="hljs-string">'ELEMENT'</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：如果是其他组件，该如何设置？</p><p>例：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><br></code></pre></td></tr></table></figure><p>则写法则是：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">//<span class="hljs-keyword">from</span>的部分在前，<span class="hljs-keyword">import</span>的部分在后<br><span class="hljs-string">'vue'</span>: <span class="hljs-string">'Vue'</span><br></code></pre></td></tr></table></figure><h4 id="2、在main-js中设置"><a href="#2、在main-js中设置" class="headerlink" title="2、在main.js中设置"></a>2、在main.js中设置</h4><p>在main.js中将CSS文件注释掉，让他们通过CDN加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//import 'view-design/dist/styles/iview.css';</span><br><span class="hljs-comment">//import 'element-ui/lib/theme-chalk/index.css'</span><br></code></pre></td></tr></table></figure><h4 id="3、在index-html中引入CDN"><a href="#3、在index-html中引入CDN" class="headerlink" title="3、在index.html中引入CDN"></a>3、在index.html中引入CDN</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://unpkg.com/element-ui@2.13.0/lib/theme-chalk/index.css"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://unpkg.com/iview@3.5.4/dist/styles/iview.css"</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/vue@2.6.10/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/vue-router@3.1.3/dist/vue-router.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/element-ui@2.13.0/lib/index.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="三、优化效果"><a href="#三、优化效果" class="headerlink" title="三、优化效果"></a>三、优化效果</h3><p>在结束优化后，vender文件大小都缩小到了80kb，其中CSS文件大小都只有几kb。 根据加载的waterfall，加载时间在2s左右，加载瓶颈在CDN的速度，比起之前的10s+已经有了很大的优化。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java TCP文件上传小程序</title>
    <link href="/posts/java-tcp-program/"/>
    <url>/posts/java-tcp-program/</url>
    
    <content type="html"><![CDATA[<p>一个基于TCP的简单的文件上传程序</p><hr><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//文件路径和文件</span><br>        String filePath;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        System.out.println(<span class="hljs-string">"输入要上传的文件地址："</span>);<br>        filePath = sc.nextLine();<br>        <span class="hljs-comment">//创建本地字节输入流，读取文件</span><br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(filePath);<br>        <span class="hljs-comment">//服务器地址及端口</span><br>        Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">7222</span>);<br>        <span class="hljs-comment">//创建网络字节输出流，向服务器传递文件</span><br>        OutputStream os = socket.getOutputStream();<br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((len = fis.read(bytes)) != -<span class="hljs-number">1</span>) &#123;<br>            os.write(bytes, <span class="hljs-number">0</span>, len);<br>        &#125;<br>        <span class="hljs-comment">//shutdown结束上传</span><br>        socket.shutdownOutput();<br>        <span class="hljs-comment">//创建网络字节输入流，读取服务器传递的信息</span><br>        InputStream is = socket.getInputStream();<br>        <span class="hljs-keyword">while</span>((len = is.read(bytes)) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-keyword">new</span> String(bytes, <span class="hljs-number">0</span>, len));<br>        &#125;<br>        <span class="hljs-comment">//关闭</span><br>        fis.close();<br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//创建服务器端口</span><br>        ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">7222</span>);<br>        <span class="hljs-comment">//使用while使服务器保持监听状态</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-comment">//接受客户端请求</span><br>            Socket socket = server.accept();<br>            <span class="hljs-comment">//使用多线程上传</span><br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">//创建网络字节输入流，收取客户端上传的文件</span><br>                        InputStream is = socket.getInputStream();<br>                        <span class="hljs-comment">//判断文件夹是否存在，不存在则创建文件夹</span><br>                        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\UpdatePath"</span>);<br>                        <span class="hljs-keyword">if</span> (!file.exists()) &#123;<br>                            file.mkdirs();<br>                        &#125;<br>                        <span class="hljs-comment">//创建上传文件的命名规则</span><br>                        <span class="hljs-comment">//int nums = 0;</span><br>                        String fileName = <span class="hljs-string">"File"</span> + System.currentTimeMillis() + <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">99</span>) + <span class="hljs-string">".zip"</span>;<br>                        <span class="hljs-comment">//nums++;</span><br>                        <span class="hljs-comment">//创建本地字节输出流，向硬盘中保存文件</span><br>                        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(file + <span class="hljs-string">"\\"</span> + fileName);<br>                        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>                        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>                        <span class="hljs-keyword">while</span> ((len = is.read(bytes)) != -<span class="hljs-number">1</span>) &#123;<br>                            fos.write(bytes, <span class="hljs-number">0</span>, len);<br>                        &#125;<br>                        <span class="hljs-comment">//创建网络字节输出流，向客户端发送已经上传完成的信息</span><br>                        OutputStream os = socket.getOutputStream();<br>                        os.write(<span class="hljs-string">"Update complete! =w= ~"</span>.getBytes());<br>                        <span class="hljs-comment">//关闭</span><br>                        fos.close();<br>                        socket.close();<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                        System.out.println(e);<br>                    &#125;<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>        <span class="hljs-comment">//server.close();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>以后有空可以再完善一下，识别上传文件的文件类型和文件名</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“过完这个冬季，你是否一如往昔”</title>
    <link href="/posts/guo-wan-zhe-ge-dong-ji/"/>
    <url>/posts/guo-wan-zhe-ge-dong-ji/</url>
    
    <content type="html"><![CDATA[<blockquote><p>以前拍照，拍完过后都会直接p完发出来，特别急。现在就喜欢憋一憋了，一些好看的照片，会在硬盘上存着，等着哪天心情愉悦或是沮丧的时候，再把它们拿出来，发个朋友圈，微博。</p></blockquote><p>这是一组冬天的胶片，重庆的冬天，阳光和蓝天是特别珍贵的东西。所以我也按下了快门，把这些景色存在了胶片里</p><hr><img src="https://s2.ax1x.com/2020/03/10/8CL1xI.jpg" srcset="/img/loading.gif" /><img src="https://s2.ax1x.com/2020/03/10/8CLUIg.jpg" srcset="/img/loading.gif"/><img src="https://s2.ax1x.com/2020/03/10/8CL0Rs.jpg" srcset="/img/loading.gif" /><img src="https://s2.ax1x.com/2020/03/10/8CLss0.jpg" srcset="/img/loading.gif" /><img src="https://s2.ax1x.com/2020/03/10/8CL2oF.jpg" srcset="/img/loading.gif" /><img src="https://s2.ax1x.com/2020/03/10/8CLfJJ.jpg" srcset="/img/loading.gif"/>]]></content>
    
    
    <categories>
      
      <category>摄影</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
